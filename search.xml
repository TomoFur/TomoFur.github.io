<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可以继承的css属性</title>
      <link href="/2019/08/30/%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84css%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/30/%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84css%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>字体系列属性<ol><li>font，</li><li>font-style，</li><li>font-weight,</li><li>font-size ,</li><li>font-family, </li><li>line-hegiht</li></ol></li><li>文本系列属性：<ol><li>color</li><li>letter-sapcing</li><li>lext-align</li><li>text-decoration</li><li>text-indent</li><li>text-shadow</li><li>text-transform</li><li>word-spacing</li></ol></li><li>列表属性：<ol><li>list-style</li><li>list-style-image</li><li>list-style-position</li><li>list-style-type</li></ol></li><li>所有元素都可以继承的属性：<ol><li>元素可见性：visiblity，opacity</li><li>光标属性：cursor</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻击</title>
      <link href="/2019/08/07/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
      <url>/2019/08/07/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Cross-Site-Scripting-xss-跨站脚本攻击"><a href="#Cross-Site-Scripting-xss-跨站脚本攻击" class="headerlink" title="Cross-Site-Scripting(xss)跨站脚本攻击"></a>Cross-Site-Scripting(xss)跨站脚本攻击</h2><p>为了不和层叠样式表的缩写混淆，故将跨站脚本攻击写为XSS.恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的.</p><h3 id="非持续型xss攻击"><a href="#非持续型xss攻击" class="headerlink" title="非持续型xss攻击"></a>非持续型xss攻击</h3><p>非持久性型xss攻击是一次性的，仅对档次的页面访问产生影响，非持久型xss攻击要求永固访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。</p><h3 id="持久型xss攻击"><a href="#持久型xss攻击" class="headerlink" title="持久型xss攻击"></a>持久型xss攻击</h3><p>持久型xss攻击会把攻击者的数据存储在服务端，攻击行为将伴随着攻击数据一直存在。</p><h3 id="DOM-Based-xss-基于dom的跨站脚本攻击"><a href="#DOM-Based-xss-基于dom的跨站脚本攻击" class="headerlink" title="DOM Based xss 基于dom的跨站脚本攻击"></a>DOM Based xss 基于dom的跨站脚本攻击</h3><p>当用户能够通过交互修改浏览器页面中的DOM并显示在浏览器上时，就可能产生这种漏洞，即通过修改页面的DOM节点形成的xss，称之为DOMBasedXSS。在这种攻击下攻击者可以随意创建，删除和更改DOM树节点。</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>主要思路有以下几点：</p><ol><li>输入有效性检测<ol><li>检测输入长度，类型，语法等的有效性。</li><li>拒绝无效的恶意的输入数据。</li></ol></li><li>对输出进行html编码<ol><li>实体在呈现HTML.XML等之前对所有用户的数据进行编码，使其不能作为脚本运行。</li></ol></li><li><strong>CSP Content-Security-Policy(内容安全策略)</strong><br> CSP本质上是建立白名单，开发者告诉浏览器哪些外部资源可以加载或者是执行，我们只需要配置规则，如何拦截是由浏览器自己实现的，我们可以通过这种方式来尽量减少XSS攻击<br> 通常情况下，有两种方法开启CSP:<ol><li>设置HTTP Header中的Content-Security-policy<ol><li>只允许加载本站资源：<code>Content-Security-Policy:default-src &#39;self&#39;</code></li><li>只允许加载HTTPS协议图片：<code>Content-Security-Police:img-src https://*</code></li><li>允许加载任何来源框架：<code>Content-Security-Police:child-src &#39;none&#39;</code></li></ol></li><li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ol></li></ol><h2 id="Cross-Site-Requset-Forgey-CSRF-跨站请求伪造"><a href="#Cross-Site-Requset-Forgey-CSRF-跨站请求伪造" class="headerlink" title="Cross-Site Requset Forgey(CSRF)跨站请求伪造"></a>Cross-Site Requset Forgey(CSRF)跨站请求伪造</h2><p>也被称为“one click attack”或者session riding。是一种对网站的恶意利用。下图是一个CSRF攻击的原理图</p><p><img src="/2019/08/07/网络攻击/csrf.png" alt></p><p>从上图可以看出来，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie</li><li>在不退出A的情况下，访问危险网站B</li></ol><p>举一个简单的例子：一个网站用户Bob可能在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息，设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><ol><li>对于敏感数据，例如银行账户信息等，要避免使用GET请求，更多的去使用POST请求。</li><li>CRFS在攻击的时候往往是在用户不知情的情况下提交的请求，我们可以使用验证码来强制跟用户交互。</li><li>在重要的请求中添加Token。CSRF攻击成功在于攻击者能够预测所有的参数从而构造出合法的请求，所以我们可以加大这个预测难度，加入一些黑客不能伪造的信息，在我们提交表单的时候，在保持原有参数不变，另外添加一个参数Token，该值是随机且加密的，当提交表单时，客户端也同时提交这个token，然后由服务端验证，验证通过才是有效的请求</li><li>检测Referer.所谓Referer，就是在一个网络请求头中的键值对，标示着目前的请求是从哪个页面过来的。服务器通过检查Referer的值，如果判断出Referer并非本站页面，而是一个外部站点的页面，那么我们就可以判断出这个请求是非法的。与此同时，我们也就检测到了一次csrf攻击</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现继承的方法</title>
      <link href="/2019/08/06/%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/08/06/%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//简易版</span><span class="token keyword">function</span> <span class="token function">extend</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span>Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    Target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Target<span class="token punctuation">;</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//YUI库中的写法</span><span class="token keyword">var</span> extend <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span>Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>        F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>        target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Target<span class="token punctuation">;</span>        target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="借用原型链实现继承"><a href="#借用原型链实现继承" class="headerlink" title="借用原型链实现继承"></a>借用原型链实现继承</h2><p><strong>基本思想</strong>：利用原型让一个引用类型继承另一个引用类型的属性和方法，实现的本质是<strong>重写原型对象，代之以一个新类型的实例。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSuperValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//继承SuperType</span>SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSubValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//true</span>instance<span class="token punctuation">.</span><span class="token function">getSubValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//false</span></code></pre><p><strong>缺点</strong>：</p><ol><li>包含引用类型值的原型属性会被所有实例共享。这样，一个实例修改了原型对象中引用类型值的原型属性，会在另外一个实例对象上也体现出来这种修改。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">,</span><span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span>color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//['red','green','blue','yellow']</span></code></pre><ol start="2"><li>在创建子类的实例时，无法向超类的构造函数中传递参数。</li></ol><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p><strong>思想</strong>：在子类构造函数的内部调用超类构造函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>gender<span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//就是这一步继承了superType。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> SuperType <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> SubType <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/2019/08/06/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/06/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个知识点还是有一些繁琐。需要认真理解并记忆</p></blockquote><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>ToString负责处理非字符串到字符串的强制类型转换</p><ol><li><p><strong>基本类型的值转换为字符串</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">null</span> 转化为<span class="token string">'null'</span>undefined 转化为<span class="token string">'undefined'</span><span class="token boolean">true</span> 转化为<span class="token string">'true'</span>数字的字符串转化规则遵守通用规则</code></pre></li><li><p>对于普通对象来说，如果没有自定义toString()方法，则返回<code>[object Object]</code>,如果有自己的toSting方法，就会调用该方法并返回值</p></li><li><p>数组的toString()返回所有单元字符串化后用’,’连接起来。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//结果为'a,b,c'</span></code></pre></li></ol><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><ol><li><p>基本类型的值转化为数字</p><pre class=" language-JavaScript"><code class="language-JavaScript">null 转化为0undefined 转化为 NaNtrue 转化为1，false转化为 0字符串的处理遵循通用规则</code></pre></li><li><p>对象或数组首先会被转化为响应的基本类型，如果返回的是非数字的基本类型，再按照以上规则进行转换，其中对象转换为基本类型时会使用ToPrimitive操作。</p></li></ol><h2 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h2><p>ToPrimitive操作会首先检查对象是否有valueOf()方法，如果有并且<strong>返回基本类型的值</strong>，就调用该方法进行类型转换，如果没有就使用toSting类型的返回的值。</p><p>如果valueOf()和toString均不返回基本类型的值，就会产生TypeError错误</p><p>如果没有对对象的valueOf()和toString()方法重写，那么：</p><p>对象的valueOf()返回对象本身，toString()返回<code>[object Object]</code></p><p>数组的valueOf()返回数组本身，toSring()返回所有单元字符串化以后再用’,’连接。</p><h2 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h2><ol><li><code>null</code>转为<code>false</code></li><li><code>undefined</code>转为<code>false</code></li><li>除了<code>&#39;&#39;</code>以外都转为<code>true</code></li><li>除了<code>0</code>和<code>NaN</code>以外都转为<code>true</code></li><li>所有对象都转为<code>true</code></li></ol><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="字符串和数字之间的隐式类型转换"><a href="#字符串和数字之间的隐式类型转换" class="headerlink" title="字符串和数字之间的隐式类型转换"></a>字符串和数字之间的隐式类型转换</h3><h4 id="数字转为字符串"><a href="#数字转为字符串" class="headerlink" title="数字转为字符串"></a>数字转为字符串</h4><p><code>+</code>运算符即能够用于数字相加，也可以用于字符串拼接，简单理解应当是<strong>如果<code>+</code>运算符的操作数其中一个是字符串或者可以通过ToPrimitive(针对对象，也包括数组)转为字符串的则执行字符串的拼接，负责执行数字相加</strong></p><h4 id="字符串转化为数字"><a href="#字符串转化为数字" class="headerlink" title="字符串转化为数字"></a>字符串转化为数字</h4><p><code>-</code>,<code>*</code>,<code>/</code>都可以用来将字符串转化为数字，其规则和+相似。</p><h3 id="隐式类型转化为布尔值"><a href="#隐式类型转化为布尔值" class="headerlink" title="隐式类型转化为布尔值"></a>隐式类型转化为布尔值</h3><p>以下几种情况会发生隐式类型转换为布尔值</p><ol><li><code>if()</code>条件判断语句</li><li><code>for()</code>中的条件判断语句</li><li><code>while()</code>和<code>do...while()</code>中的条件判断语句</li><li><code>?:</code>三目运算符中的条件判断语句</li><li>逻辑运算符<code>||</code>和<code>&amp;&amp;</code>左边的操作数</li></ol><h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="||和&amp;&amp;"></a>||和&amp;&amp;</h3><p><code>&amp;&amp;</code>和<code>||</code>运算符并不一定返回布尔值，他实际返回的是两个操作数中的一个的值</p><p><code>&amp;&amp;</code>和<code>||</code>首先对第一个操作数进行条件判断，如果第一个操作数不是布尔类型的值，则会被转为布尔类型的值，再进行下面的判断</p><p>对于<code>||</code>而言，如果第一个操作数条件判断结果为true，则返回第一个操作数，否则，返回第二个操作数</p><p>对于<code>&amp;&amp;</code>而言，如果第一个操作数条件判断结果为false，则反返回第一个操作数，否则，返回第二个操作数。</p><h2 id="强制类型转换：-和"><a href="#强制类型转换：-和" class="headerlink" title="强制类型转换：==和==="></a>强制类型转换：<code>==</code>和<code>===</code></h2><p>正确理解：<code>==</code>允许在相等比较中进行强制类型转换，而<code>===</code>不允许</p><ol><li><strong>字符串和数字之间的相等比较：将字符串转换为数字进行相等比较</strong></li><li><strong>其他类型与布尔值之间的相等比较：将布尔值转换为数字进行比较</strong></li><li>对象和非对象之间的相等比较：<ol><li>如果x是数字或者字符串，y是对象，则返回 <code>x==ToPrimitive(y)</code></li><li>如果x是对象，y是字符串或者数字，则返回<code>ToPrimitive(x)==y</code></li></ol></li></ol><p><strong>Tips</strong>:</p><blockquote><p>之所以 typeof null === ‘object’是因为在JavaScript中不同的对象在底层都是表示为二进制，而二进制前三位都为0的话会被判断为object类型,null的二进制全是0,所以在执行typeof时会返回‘object’</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的方法</title>
      <link href="/2019/08/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>name <span class="token operator">=</span>name<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意</strong></p><ol><li>使用工厂模式创建对象对象的时候，不需要使用new操作符，直接当成普通函数调用就行</li><li>工厂模式创建对象最后要将obj返回。</li></ol><p><strong>缺点</strong>：无法解决对象识别的问题。即无法知道一个对象的类型。</p><h2 id="构造器-构造函数-模式"><a href="#构造器-构造函数-模式" class="headerlink" title="构造器(构造函数)模式"></a>构造器(构造函数)模式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> CreateObject <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>注意</strong></p><ol><li>使用构造函数创建对象的时候，需要使用new操作符。</li><li>构造函数内部不需要有对象返回。</li><li><strong>构造函数不需要显式的返回一个值，在使用new来创建一个对象的时候，如果return的是一个非对象，则会忽略返回值，如果return的是一个对象，则会返回这个对象</strong></li></ol><p>使用构造函数创建对象的时候发生的事情：</p><ol><li>在内存中开辟一个空间，这个空间用于存储创建的新的对象</li><li>将this指向这个空间</li><li>将新生成的这个对象的<code>__proto__</code>指向构造函数的<code>prototype</code>.这一步是建立对象和原型直接的对应关系</li><li>执行构造函数中的代码（为这个对象添加属性和方法）</li><li>将新对象返回。（将this返回）</li></ol><p><strong>缺点</strong>：每个方法都要在实例对象上重新创建一次，因此，不同实例上的同名函数是不相等的。这样极大的浪费了存储空间。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> Person <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> b<span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">'c'</span><span class="token punctuation">;</span></code></pre><p><img src="/2019/08/06/创建对象/原型图解.PNG" alt></p><p><strong>注意</strong></p><ol><li>构造函数中有一个<strong>prototype</strong>属性，指向这个构造函数的原型对象</li><li>原型对象中有一个<strong>constructor</strong>属性，指向这个原型对象对应的构造函数</li><li>由构造函数实例化出来的实例对象中有一个<strong>proto</strong>属性，同样也指向实例对象所对应的构造函数的原型对象。</li></ol><p><strong>缺点</strong></p><ol><li>使用原型模式创建对象的时候，如果存在有引用类型的属性，如果生成了两个实例对象，其中一个实例对象改变了这个引用类型的属性，则另外一个实例对象的该属性的值也会改变。</li></ol><h2 id="组合使用构造函数模式和原型模式——-最优模式"><a href="#组合使用构造函数模式和原型模式——-最优模式" class="headerlink" title="组合使用构造函数模式和原型模式——-最优模式"></a>组合使用构造函数模式和原型模式——-最优模式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//构造函数模式用于定义实例属性</span><span class="token keyword">function</span> Person <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原型模式用户定义方法和共享属性。</span>Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span><span class="token punctuation">{</span>    constructor<span class="token punctuation">:</span>Person<span class="token punctuation">,</span>    sayName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议状态码</title>
      <link href="/2019/07/10/HTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2019/07/10/HTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议状态码"><a href="#HTTP协议状态码" class="headerlink" title="HTTP协议状态码"></a>HTTP协议状态码</h1><blockquote><p>常用的不多，其余的权当了解一下</p></blockquote><h2 id="1-信息性状态码"><a href="#1-信息性状态码" class="headerlink" title="1**     信息性状态码"></a>1**     信息性状态码</h2><ol><li><code>100 continue</code>:服务器端收到了初始部分，请客户端继续</li></ol><p><strong>注</strong>：这个状态码是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或者使用的大的实体时，才使用这个状态码</p><ol start="2"><li><code>101 switching protocol</code>:服务器正在根据客户端的指定，将协议切换成update首部所列的协议</li></ol><h2 id="2-成功状态码"><a href="#2-成功状态码" class="headerlink" title="2**      成功状态码"></a>2**      成功状态码</h2><ol><li><code>200 ok</code>:请求成功，响应报文的主体部分包括了所请求的资源</li><li><code>201 created</code>:用于创建服务器对象的请求，例如<code>put</code></li><li><code>202 Accepted</code>:请求已经被接受，但是服务器还未对齐执行任何操作</li><li><code>203 Not-Authoritative</code>:实体首部包含的信息不是来自于源端服务器，而是来自于资源的一个副本。</li><li><code>204 no content</code>:响应报文的主体部分没有内容</li><li><code>205 reset Content</code>:用于重置表单内容</li><li><code>206 partial content</code>:成功执行一个部分请求，一般这种响应的请求报文的首部字段都有一个<code>content-range</code>字段</li></ol><h2 id="3-重定向状态码"><a href="#3-重定向状态码" class="headerlink" title="3**        重定向状态码"></a>3**        重定向状态码</h2><ol><li><code>300 multiple choice</code>:请求的url对应着服务器的多个资源</li><li><code>301 moved permanently</code>:请求的url已经被移除了</li><li><code>302 found</code>:客户端应该使用<code>location</code>首部给出的URL来临时定位资源，将来的请求仍然使用老的URL</li><li><code>303 see other</code>:告知客户端应该使用另外一个URL来获取资源</li><li><code>304 not modified</code>:客户端请求的资源并没有被修改，在协商缓存的时候通过<code>expire</code>或者<code>Etag</code>来判断</li><li><code>307 temporary redirect</code>:客户端应该使用<code>location</code>首部给出的URL来临时定位资源，将来的请求仍然使用老的UR</li></ol><h4 id="302，303，307之间的区别："><a href="#302，303，307之间的区别：" class="headerlink" title="302，303，307之间的区别："></a>302，303，307之间的区别：</h4><p>当<strong>HTTP/1.0</strong>客户端发起一个POST请求，并在响应中收到302重定向状态码时，它会接受Location首部的重定向URL,并向那个URL发起一个GET请求（实际上并不希望用GET来代替POST,这种行为实际上时不合法的）。</p><p>在HTTP/1.1规范使用303状态码来实现同样的行为(承认POST变GET的合法性)</p><p>对于HTTP/1.1客户端，用307状态码取代302状态码来进行临时重定向。(实际上时实现了HTTP/1.0中302的理想型作用，不会将POST变为GET)</p><h2 id="4-客户端错误的状态码"><a href="#4-客户端错误的状态码" class="headerlink" title="4**      客户端错误的状态码"></a>4**      客户端错误的状态码</h2><ol><li><code>400 bad request</code>:客户端发送了一个错误的请求</li><li><code>401 Unauthorized</code>:告知客户端在对资源进行访问之前，需要对自身进行认证</li><li><code>403 forbidden</code>:请求被服务器拒绝了</li><li><code>404 not found</code>:服务器无法找到这个资源</li><li><code>405 method not allow</code>:这个资源不支持请求发起的方法</li><li><code>408 request timeout</code>:请求超时</li><li><code>409 conflict</code>:请求可能在资源上会引起一些冲突</li><li><code>410 gone</code>:请求的资源已经被删除了</li></ol><h2 id="5-服务器端错误的状态码"><a href="#5-服务器端错误的状态码" class="headerlink" title="5**    服务器端错误的状态码"></a>5**    服务器端错误的状态码</h2><ol><li><code>500  Internal Server Error</code>:服务器内部发生错误</li><li><code>501 no implement</code>:客户端发起的请求超出了服务器的能力范围</li><li><code>502 bad gateway</code>网关错误</li><li><code>503 Service Unavailable</code>:服务器现在不可用</li><li><code>504 gateway timeout</code>:网关请求超时</li><li><code>505 HTTP version not support</code>:不支持这个版本的http协议。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档对象模型(DOM)</title>
      <link href="/2019/07/09/DOM/"/>
      <url>/2019/07/09/DOM/</url>
      
        <content type="html"><![CDATA[<h1 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型(DOM)"></a>文档对象模型(DOM)</h1><p>针对HTML和XML文档的一个API,DOM描绘了一个层次化的节点树，允许开发人员添加，移除和修改页面的一部分。</p><h3 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h3><h4 id="DOM1级"><a href="#DOM1级" class="headerlink" title="DOM1级"></a>DOM1级</h4><p>定义了HTML和XML文档的底层结构，为基本的文档结构和查询提供了接口。</p><h4 id="DOM2级"><a href="#DOM2级" class="headerlink" title="DOM2级"></a>DOM2级</h4><p>对DOM1级进行扩展。</p><ol><li><strong>DOM2级核心</strong>：在1级核心基础上构建，为节点添加了更多方法和属性。</li><li><strong>DOM2级视图</strong>：为文档定义了基于样式信息的不同视图。</li><li><strong>DOM2级事件</strong>：说明了如何使用事件与DOM文档交互</li><li><strong>DOM2级样式</strong>：定义了如何以编程的方式来访问和改变css样式信息。</li><li><strong>DOM2级遍历和范围</strong>：引入了遍历DOM文档和选择其特定部分的接口</li><li><strong>DOM2级HTML</strong>:在1级HTML基础上构建，添加了更多属性，方法和新街口</li></ol><h4 id="DOM3级"><a href="#DOM3级" class="headerlink" title="DOM3级"></a>DOM3级</h4><p>3级DOM通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展。</p><h2 id="节点与元素节点"><a href="#节点与元素节点" class="headerlink" title="节点与元素节点"></a>节点与元素节点</h2><ol><li>节点包括有：元素节点，文本节点，属性节点，注释节点等</li><li>每一个节点对象有三个重要的属性：<ol><li>nodeType:节点的类型，其中1表示元素节点，2表示属性节点，3表示文本节点</li><li>nodeName：节点的名字。标签节点就是大写的标签名字，属性节点就是小写的属性名字，文本节点就是#text</li><li>nodeValue:节点的值。标签节点的值时null，属性节点的值是属性值，文本节点的值是文本。</li></ol></li></ol><p><strong>注意</strong>：一个元素的父元素和父节点都指的是包含该元素的父元素，是一个标签。但是一个元素的子元素和子节点不是同一个东西。元素的子元素特指包含在这个元素内部的所有标签。而元素的子节点则是包含在这个元素内部的所有节点，包括文本节点，属性节点，元素节点和注释节点等。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是第1个li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>这是第2个li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>这是第3个li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>这是第4个li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>这是第5个li<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>在上述例子中，ul标签的子节点有11个，而子元素只有5个。</p><h2 id="获取子节点的方法"><a href="#获取子节点的方法" class="headerlink" title="获取子节点的方法"></a>获取子节点的方法</h2><ol><li>parentNode.获取父节点。最顶端是#document</li><li>childNodes:获取所有的子节点。</li><li>firstChild:获取第一个子节点。</li><li>lastChild:获取最后一个子节点。</li><li>nextSiblings：获取后一个兄弟节点</li><li>perviousSiblings:获取前一个兄弟节点。</li><li>hasChildNodes：判断该元素是否有子节点。</li></ol><h2 id="获取子元素的方法"><a href="#获取子元素的方法" class="headerlink" title="获取子元素的方法"></a>获取子元素的方法</h2><ol><li>parentElement:获取当前元素的父元素。</li><li>children：获取当前元素的所有子元素。</li><li>childElementCount:当前元素的所有子元素的个数。</li><li>firstElementChild:返回第一个子元素节点</li><li>lastElementChild:返回最后一个子元素节点</li><li>nextElementsibling：返回下一个兄弟元素节点。</li><li>previousElementSibling:返回前一个兄弟元素节点。</li><li>attributes：获取元素的属性节点。(标签内部添加的类似于name，class，id之类的)</li></ol><p><strong>注意</strong>：获取子元素节点的方法除了children之外，其余的方法IE9以下都不兼容。</p><h2 id="DOM的其他操作"><a href="#DOM的其他操作" class="headerlink" title="DOM的其他操作"></a>DOM的其他操作</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p><code>document.createElement()</code>//参数传递的是标签名字</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol><li><code>parentNode.appendChild()</code>;//在父级元素的后面增加一个子元素</li><li><code>parentNode.insertBefore(a,b)</code>;//第一个参数是新节点，第二个参数是老节点。表示将新节点插入到老的节点之前。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>parent.removeChild()</code>;//传入的参数是被选中的要删除的节点。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>parent.replaceChild</code>(新节点，旧节点)//将旧节点替换成新节点。</p><h3 id="节点拷贝"><a href="#节点拷贝" class="headerlink" title="节点拷贝"></a>节点拷贝</h3><p><code>cloneNode()</code>//<strong>不传参数的时候是浅拷贝</strong>，只是拷贝当前元素，<strong>如果传入参数true时，表示深拷贝</strong>，会将当前节点以及其包含的子节点都拷贝一份。</p><p><strong>注意</strong>：拷贝只是拷贝元素，并不拷贝元素身上绑定的事件。</p><h3 id="操作属性："><a href="#操作属性：" class="headerlink" title="操作属性："></a>操作属性：</h3><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p><code>getAttribute(&#39;属性名&#39;)</code></p><h4 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h4><p><code>setAttribute(&#39;属性名&#39;,&#39;属性值&#39;)</code></p><p><strong>注意</strong>：</p><p>这里如果该DOM元素已经有了这个属性，通过上述方式设置属性就会把元素原来有的那个属性给覆盖掉。</p><pre class=" language-javascript"><code class="language-javascript">    情景：假设divObj是一个DOM节点，它此时有一个类样式为base<span class="token punctuation">,</span>而我们想给它在base这个类样式的基础上再添加一个active的样式    ❌<span class="token punctuation">:</span>    divObj<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span><span class="token string">'active'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    当这行代码执行结束之后，divObj的类样式只有active<span class="token punctuation">,</span>没有base，因为base被覆盖掉了    ✔：    <span class="token keyword">let</span> array<span class="token operator">=</span>divObj<span class="token punctuation">.</span>className<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取到所有的类样式组成的数组</span>    array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将active添加到这个数组里面，</span>    divObj<span class="token punctuation">.</span>className <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再将这个数组转为字符串赋值给divObj的className</span></code></pre><h4 id="移除属性"><a href="#移除属性" class="headerlink" title="移除属性"></a>移除属性</h4><p><code>removeAttribute(&#39;属性名&#39;)</code></p><h3 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h3><p>在读模式下，innerHTML属性返回与调用元素的所有子节点对应的HTML标记，在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素先前的所有子节点。（读模式下会返回带html标签的字符串，写模式下会将传入的字符串解析成为html标签，然后覆盖掉这个DOM元素之前的所有子元素。）</p><h3 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h3><p>通过innerText属性可以操作元素中包含的所有文本内容，包括子文档树中的文本，在通过innerText读取值的时候，它会按照由浅入深的顺序，将子文档中所有文本拼接起来；再通过innerText写入值时，会覆盖。如果写入的字符串中有html标签元素，也不会解析成html标签渲染到页面上，会当成普通的字符串输出。</p><p><strong>注意</strong>：<strong>这个方法IE支持，FF不支持，FF中有一个类似方法textContent</strong>。</p><h3 id="计算的属性"><a href="#计算的属性" class="headerlink" title="计算的属性"></a>计算的属性</h3><p>虽然可以通过<code>DOM对象.style.属性名称</code>的方式获取到元素的属性样式，但是，这种方式仅限于<strong>通过内联的形式写在元素标签的<code>style</code>属性里的样式信息</strong>，如果时通过外链或者写在<code>&lt;style&gt;&lt;/style&gt;</code>标签的样式信息，这种方法就无能为力了。这时候，要是想要获取相关的信息，需要通过<code>getComputedStyle()</code>方法来获取。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>style<span class="token operator">></span>    #app<span class="token punctuation">{</span>        width<span class="token punctuation">:</span>500px<span class="token punctuation">;</span>        height<span class="token punctuation">:</span>500px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    #app<span class="token punctuation">:</span><span class="token punctuation">:</span>after<span class="token punctuation">{</span>        content<span class="token punctuation">:</span><span class="token string">'hello'</span><span class="token punctuation">;</span>        display<span class="token punctuation">:</span>inlien<span class="token operator">-</span>block<span class="token punctuation">;</span>        width<span class="token punctuation">:</span>20px<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">'app'</span> style <span class="token operator">=</span> <span class="token string">'background-color:red'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    app<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width<span class="token comment" spellcheck="true">//无法获取到500px</span>    window<span class="token punctuation">.</span><span class="token function">getComputedStlye</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token comment" spellcheck="true">//500px;第二个参数是可选的，可以是一个表示伪元素的字符串</span>    <span class="token comment" spellcheck="true">//要想获得这个after伪元素的样式可以通过以下方式来获取到：</span>    window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span><span class="token string">':after'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>注意</strong>：<strong>getComputedStyle()方法FF支持，IE不支持，IE支持的是currentStyle,即要在IE上获取到width，通过<code>app.currentStyle.width</code>。这个方法Edge不支持，只有IE支持。</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h4 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h4><ol><li><p><strong>offsetWidth</strong>：元素在水平方向上占的空间大小，包括元素宽度，边框宽度等。</p></li><li><p><strong>offsetHeight</strong>:元素在垂直方向上占的空间大小。</p></li><li><p><strong>offsetLeft</strong>：元素的外左边框与父元素内左边框的距离。</p></li><li><p><strong>offsetTop</strong>:元素的外上边框与父元素的内上边框之间的距离。</p><p><img src="/2019/07/09/DOM/offset.PNG" alt></p></li></ol><h3 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h3><ol><li><strong>clientHeight</strong>：元素内容区域加上上下的内边距</li><li><strong>clientTop</strong>：元素内容区域加上左右的内边距。</li><li><strong>clientLeft</strong>：元素左边框的宽度</li><li><strong>clientTop</strong>: 元素上边框的宽度</li></ol><p><strong>注意</strong>：clientX和clientY是在注册鼠标移动事件的时候显示鼠标在屏幕上的位置用的。<code>e.clientX;e是事件源对象</code></p><p><img src="/2019/07/09/DOM/client.PNG" alt></p><h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h3><ol><li><strong>scrollHeight</strong>:在内容超过包裹元素的情况下，是内容的总高度，在没有超过情况下，是包裹内容的元素的高度</li><li><strong>scrollWidth</strong>：在内容超过包裹元素的情况下，是内容的宽度，在没有超过情况下，是包裹内容的元素的宽度</li><li><strong>scrollTop</strong>：卷曲上去的高度</li><li><strong>scrollLeft</strong>:向右卷曲出去的宽度。</li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件流：从页面中接受事件的顺序。IE是事件冒泡流，FF事件捕获流。"><a href="#事件流：从页面中接受事件的顺序。IE是事件冒泡流，FF事件捕获流。" class="headerlink" title="事件流：从页面中接受事件的顺序。IE是事件冒泡流，FF事件捕获流。"></a><strong>事件流</strong>：从页面中接受事件的顺序。IE是事件冒泡流，FF事件捕获流。</h4><h4 id="DOM事件流：事件捕获阶段——-gt-处于目标阶段——-gt-事件冒泡阶段"><a href="#DOM事件流：事件捕获阶段——-gt-处于目标阶段——-gt-事件冒泡阶段" class="headerlink" title="DOM事件流：事件捕获阶段——&gt;处于目标阶段——&gt;事件冒泡阶段"></a><strong>DOM事件流</strong>：<strong>事件捕获阶段——&gt;处于目标阶段——&gt;事件冒泡阶段</strong></h4><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a><strong>事件处理</strong></h4><ol><li><strong>DOM0级事件处理</strong>：<ol><li>绑定事件：<code>元素.on事件 = 事件处理函数</code></li><li>解绑事件：<code>元素.on事件 = null</code></li></ol></li><li><strong>DOM2级事件处理</strong>：<ol><li>绑定事件：<code>元素.addEventListener(事件名称(不带on)，事件处理函数，true/false（在捕获阶段执行/在冒泡阶段执行）)</code></li><li>解绑事件:<code>元素.removeEventListener(事件名称)</code></li></ol></li></ol><p><strong>IE事件处理</strong>：</p><p><strong>绑定事件</strong>：<code>元素.attachEvent(带on的事件名，事件处理函数)</code></p><p><strong>解绑事件</strong>：元素.detachEvent(带on的事件名)</p><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p><strong>除了IE之外</strong>：事件处理函数中传入的形参e就是事件对象</p><ol><li>e.preventDefault();//阻止默认事件</li><li>e.stopPropergation()//阻止事件冒泡</li><li>e.target//事件源对象</li><li>e.eventPhase//事件目前所处的阶段</li></ol><p><strong>IE</strong>：<strong>window.event</strong></p><ol><li>window.event.cancleBubble = true//取消事件冒泡</li><li>window.event.srcElement = e.target</li></ol><p><strong>TIPS:</strong>不会冒泡的事件有<strong>abort</strong> <strong>blur</strong> <strong>error</strong> <strong>focus</strong> <strong>load</strong> <strong>mouseenter/mouseleave</strong> <strong>resize</strong> <strong>unload</strong>  <strong>submit</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2019/07/05/promise/"/>
      <url>/2019/07/05/promise/</url>
      
        <content type="html"><![CDATA[<p>所谓promise，简单来说是一个容器，里面保存着某个未来才会结束的事情(通常是一个异步操作)的结果，从语法上来讲Promise是一个对象，从它可以获取异步操作的消息。</p><p>Promise对象代表着一个异步操作，有三种状态，Pending（进行中），Fulfilled（已成功）和Rejected（已失败）。Promise对象的状态改变只能有两种可能：从Pending变为Fulfilled和从Pending变为Rejected。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>regect<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//异步代码</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>异步操作成功<span class="token punctuation">)</span><span class="token punctuation">{</span>        resolev（异步操作结果）；    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>错误对象<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>erroe<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，它们是两个函数，由Javascript引擎提供，不用自己部署。</p><p><strong>resolve函数</strong>的作用是将Promise对象的状态从“未完成”变为“成功”，<strong>在异步操作成功时调用，并将异步操作的结果作为参数传递出去</strong>;</p><p><strong>reject函数</strong>的作用是将Promise对象的状态从“未完成”变为“失败”。在<strong>异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</strong></p><p>##Promise.prototype.then</p><p>Promise实例生成之后，可以用<strong>then</strong>方法来分别指定resolve状态和reject状态的回调。<strong>then方法可以接受两个回调函数作为参数</strong>，第一个回调函数是Promise对象的状态变为Resolved时调用的，第二个回调函数是Promise对象变为Rejected时调用的，其中，<strong>第二个函数是可选的</strong>。不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>采用链式的then可以指定一组按照次序调用的回调函数，这样，前一个回调函数有可能返回地还是一个Promise对象，而后一个回调函数就会等待该Promise对象的状态发生改变后再被调用。</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h2><p>Promise.prototype.catch方法是.then(null,reject)的别名，用于指定发生错误时的回调。</p><p><strong>注意</strong>：Promise对象的错误具有冒泡的性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个catch语句捕获。一般来说，不要再then方法中定义Reject状态的回调函数，而应总是使用catch方法。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all方法用于将多个Promise实例包装成一个新的Promise实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>p的状态由p1,p2,p3决定，分两种情况：</p><ol><li>只有p1,p2,p3状态都变为Fulfiled，p的状态才会变为Fulfiled，此时，p1,p2,p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1，p2，p3中有一个被Reject，p的状态就会变为Reject，此时，第一个被Reject的实例的返回值就会被传递给p的回调函数。</li></ol><p><strong>手动实现Promise.all</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">promiseAll</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这个函数传入的参数首先必须要是一个数组，如果不是数组，则直接抛出异常</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>promises <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Argument must be an Array'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//记录传入的promise对象的个数</span>            <span class="token keyword">let</span> len <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//记录状态为resolve的promise对象的个数</span>            <span class="token keyword">let</span> resolvedCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//保存一个promise对象的状态变为resolve之后的结果</span>            <span class="token keyword">let</span> resolvedArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//使用Promise.resolve方法将传递进来的参数转换成promise对象的实例</span>                    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//如果这个promise对象的状态变为resolve，就给负责技术的变量加1</span>                        resolvedCount<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//将这个异步操作的结果保存在刚开始设定的数组里</span>                        resolvedArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//当所有的promise对象的状态都变为resolve的时候，这个最外面返回的promise对象的状态变为resolve，然后将保存之前的所有promise实例的结果的数组返回</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>resolvedCount <span class="token operator">===</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>resolvedArray<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>rej<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//如果有一个实例的状态变成了reject，则直接将要返回的这个promise实例对象的状态变为reject并返回即可。</span>                        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>rej<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reason<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>Promise.race方法用于将多个Promise实例包装成一个新的Promise实例。和Promise.all不同的是，只要多个Promise实例中的一个改变了状态，包装出来的这个新实例的状态就会跟着改变。那个率先改变的Promise实例的返回值就会传递给p的回调函数。本身并不会关注这个改变状态的promise的实例的状态是变成了resolved还是rejected。</p><p>​    <strong>手动实现Promise.race</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//有了promise.all的实现思路，再实现race方法就简单很多了</span> <span class="token keyword">function</span> <span class="token function">promiseRace</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>promises <span class="token keyword">instanceof</span> <span class="token class-name">array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Argument must be an Array'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">let</span> length <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>rej<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>rej<span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reason <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p>Promise.resolve方法将现有的对象转为Promise对象。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>等价于：<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端1px适配</title>
      <link href="/2019/07/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E9%80%82%E9%85%8D/"/>
      <url>/2019/07/02/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>明明设置了边框是1px，你为什么在移动端上看起来像2px？</p></blockquote><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>采用<code>box-shadow</code></p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span><span class="token number">0</span>px <span class="token number">1</span>px <span class="token number">1</span>px -<span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>//下边线    <span class="token property">box-shadow</span><span class="token punctuation">:</span><span class="token number">0</span>px -<span class="token number">1</span>px <span class="token number">1</span>px -<span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>//上边线    <span class="token property">box-shadow</span><span class="token punctuation">:</span><span class="token number">1</span>px <span class="token number">0</span>px <span class="token number">1</span>px -<span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>//右边线    <span class="token property">box-shadow</span><span class="token punctuation">:</span>-<span class="token number">1</span>px <span class="token number">0</span>px <span class="token number">1</span>px -<span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>//左边线<span class="token punctuation">}</span></code></pre><h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><p>采用伪元素和<code>transform:scale();</code>来实现</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//左边线<span class="token class">.box</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform-origin</span><span class="token punctuation">:</span>left top<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//右边线<span class="token class">.box</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform-origin</span><span class="token punctuation">:</span>right top<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//上边线<span class="token class">.box</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform-origin</span><span class="token punctuation">:</span>left top<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//下边线<span class="token class">.box</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform-origin</span><span class="token punctuation">:</span>left bottom<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">//四边都有<span class="token class">.box</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">box-sizing</span><span class="token punctuation">:</span>border-box<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">200%</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span><span class="token number">1</span>px solid <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">transform-origin</span><span class="token punctuation">:</span>left top<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>Tips</strong>:</p><p>​    水平的边<code>width:100%;height:1px;</code></p><p>​    垂直的边:<code>height:100%,width:1px</code>;    </p><h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>通过设置viewport的scale值。还没有理解这种方法，先贴上链接，以后再去慢慢研究</p><p><a href="https://juejin.im/post/5c8ba122e51d4574cf120378#heading-7" target="_blank" rel="noopener">移动端1px解决方案</a> </p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现call，apply和bind</title>
      <link href="/2019/07/02/%E6%89%8B%E5%8A%A8%E5%86%99%E6%BA%90%E7%A0%81/"/>
      <url>/2019/07/02/%E6%89%8B%E5%8A%A8%E5%86%99%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>还是有点东西的呦！</p></blockquote><h2 id="手动实现call"><a href="#手动实现call" class="headerlink" title="手动实现call"></a>手动实现call</h2><p><strong>预备知识</strong>：<strong>如果一个函数作为一个对象的属性，那么通过对象的.运算符调用此函数，this就是此对象</strong></p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这里的这个this就是使用call的那个函数。因为是写在函数的原型上的，所以当一个具体的函数调用这个方法的时候，this就指向这个函数本身。本质上是给传入的这个对象先添加一个属性fn，这个属性的值就是调用call的那个函数。</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在调用完毕之后将这个fn属性删除掉。</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>测试<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">'张三'</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token number">10</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>getInfo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="手动实现apply"><a href="#手动实现apply" class="headerlink" title="手动实现apply"></a>手动实现apply</h2><p>在实现了call之后，实现apply相对来说就简单了，无非是传入参数不同而已。</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>apply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token string">'李四'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">}</span>test<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h2><pre class=" language-javascript"><code class="language-javascript">Fucntion<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里的判断是为了处理绑定的函数被用于new操作来创建新的对象，此时的this是指向新new出来的对象。不再是调用bind的那个函数了。</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">that</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> that<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重排和重绘</title>
      <link href="/2019/07/01/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2019/07/01/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器的运行机制："><a href="#浏览器的运行机制：" class="headerlink" title="浏览器的运行机制："></a>浏览器的运行机制：</h2><ol><li>构建DOM树：渲染引擎解析HTML文档，首先将标签转换为DOM树中的DOM节点（包括js生成的标签），生成DOM树</li><li>构建渲染树：解析对应的CSS样式文件信息（包括js生成的样式和外部CSS文件），构建渲染树。</li><li>布局渲染树：计算每一个元素的大小，位置等，给出每一个元素应该在屏幕上出现的精确坐标。</li><li>绘制渲染树：遍历渲染树，使用UI后端来绘制每一个节点。</li></ol><h2 id="重绘："><a href="#重绘：" class="headerlink" title="重绘："></a>重绘：</h2><p>当盒子的位置，大小以及其他属性例如颜色，字体等大小等都确定下来之后，浏览器便把这些元素都按照各自的特性绘制一遍，将内容呈现在页面上。<strong>重绘</strong>是指一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使得元素呈现出新的外观。</p><p><strong>触发条件</strong>：改变元素的外观属性，如：color，background-color等。</p><h2 id="重排："><a href="#重排：" class="headerlink" title="重排："></a>重排：</h2><p>当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为重排，每个页面最少需要一次重排，就是在页面第一次加载的时候。</p><p><strong>触发条件</strong>：任何页面布局和几何属性的改变都会触发重排，例如：</p><ol><li>页面初始化渲染</li><li>添加或者删除可见的DOM元素</li><li>元素的位置的改变</li><li>元素的尺寸发生改变，如大小，外边距，边框等</li><li>浏览器窗口尺寸发生改变</li><li>填充内容的改变，如文本的改变或者图片大小的改变而引起的计算高度和宽度的变化</li><li>读取某些元素属性：(offsetLeft/Top/Height/Width,clientTop/Height/Width/Left,scrollTop/Left/Width/Height,width/height,　getComputedStyle(),　currentStyle(IE))</li></ol><h2 id="重排和重绘的关系："><a href="#重排和重绘的关系：" class="headerlink" title="重排和重绘的关系："></a>重排和重绘的关系：</h2><p>在重排的时候，浏览器会使得渲染树中受到影响的部分失效，并重新构建这部分渲染树，完成重排之后，浏览器会重新绘制受影响的部分到页面上。所以<strong>重排必定引起重绘，但是重绘不一定会导致重排</strong></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li>浏览器自己的优化：浏览器会维护一个队列，把所有会引起重排重绘的操作放到这个队列里面，等队列中的操作到了一定数量或者一定时间间隔的时候，浏览器就会flush队列，进行一个批处理，将多次的重排重绘变为执行一次重排重绘。</li><li>样式集中改变，可以通过添加类名来进行样式修改</li><li>等等…..</li></ol>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习---基础配置篇</title>
      <link href="/2019/06/27/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>/2019/06/27/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>webpack：模块打包机</p><p>webpack安装：推荐在项目内本地安装，不推荐使用全局安装。</p><p>如果配置文件的名字不是<code>webpack.config.js</code>的话，在使用<code>npx webpack</code>进行打包的时候要<code>npx webpack --config 自定义的配置文件名字</code></p><p>webpack-cli的作用：可以使我们在命令行中运行webpack这个指令，如果不安装webpack-cli，则在命令行中运行webpack指令会报错。</p><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><h3 id="webpack可以0配置：不需要写任何配置文件，直接运行npx-webpack"><a href="#webpack可以0配置：不需要写任何配置文件，直接运行npx-webpack" class="headerlink" title="webpack可以0配置：不需要写任何配置文件，直接运行npx webpack"></a>webpack可以0配置：不需要写任何配置文件，直接运行npx webpack</h3><p>打包指令为<code>npx webpack</code>此时打包的是src目录下的index.js文件，打包生成的是和src文件同级的dist文件下的main.js文件。</p><p><strong>注</strong>：打包是为了支持js的模块化，如果在index.js中使用了Common.js的语法规范，即通过require的方式引入了一个模块，本来index.js是无法运行在浏览器环境下的，通过打包之后生成的main.js就可以运行在浏览器环境下了。</p><h3 id="通过配置文件来进行配置"><a href="#通过配置文件来进行配置" class="headerlink" title="通过配置文件来进行配置"></a>通过配置文件来进行配置</h3><p>默认的webpack的配置文件名为<code>webpack.config.js</code></p><p>下面是一个配置文件的基本结构</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//模式：可以选择是生产模式或者是开发模式，在生产模式下，打包的js文件会被压缩。</span>    mode<span class="token punctuation">:</span><span class="token string">'development'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//打包文件的入口地址</span>    entry<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./index.js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//打包文件的出口地址</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//打包文件将来存放的地址，这个地址必须是一个绝对地址。这里会新生成一个dist目录。打包出来的文件就在这个文件夹下面。</span>        filename：<span class="token string">'bundle.js'</span><span class="token comment" spellcheck="true">//打包后输出的文件名字。</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//开发服务器的配置，也就是webpack-dev-server的配置</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        port<span class="token punctuation">:</span><span class="token number">3000</span><span class="token comment" spellcheck="true">//端口号</span>        contentBase<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//指定托管到电脑的内存中的路径</span>        open：<span class="token boolean">true</span><span class="token comment" spellcheck="true">//自动打开浏览器</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//这里放着webpack的所有插件</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span><span class="token string">''</span><span class="token comment" spellcheck="true">//模板对象，一般是src目录下的index.html</span>            filename<span class="token punctuation">:</span><span class="token string">'index.html'</span><span class="token comment" spellcheck="true">//在内存中生成的文件名字</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//这里放着所有的模块</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token comment" spellcheck="true">//规则</span>            <span class="token comment" spellcheck="true">//css-loader是解析@import这种语法的</span>            <span class="token comment" spellcheck="true">//style-loader是把css文件插入到head标签中</span>            <span class="token comment" spellcheck="true">//loader的特点是希望用途单一</span>            <span class="token comment" spellcheck="true">//loader的顺序默认是从右向左执行。</span>            <span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.css$/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//处理css文件的loader</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="打包其他格式的文件"><a href="#打包其他格式的文件" class="headerlink" title="打包其他格式的文件"></a>打包其他格式的文件</h2><p>默认情况下，webpack只能打包js文件，在需要打包其他格式的文件的时候，需要安装对应的loader，并在webpack.config.js中的module中去添加相对应的匹配规则。</p><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>作用：Loader直译为”加载器“,webpack将一切文件都看成是模块，但是原声带webpack只能解析js文件，如果其他文件也想被打包的话，就会用到相应的loader，所以loader的作用是让webpack拥有加载和解析非JavaScript文件的能力。</p><h2 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h2><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span><span class="token regex">/\.(jpg|png|gif)$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span><span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span><span class="token string">'file-loader'</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span><span class="token punctuation">{</span>                        name<span class="token punctuation">:</span><span class="token string">'[name]_[hash:8].[ext]'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//打包的图片的名字是源文件名字_8位hash</span>                        outputPath<span class="token punctuation">:</span><span class="token string">'images/'</span><span class="token comment" spellcheck="true">//打包输出的图片存放在dist目录下的images文件里。</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h2><p>把图片转化为base64的字符串插入到打包的js文件里，减少了依次http请求。缺点是如果打包的文件特别大，生成的base64字符串也会特别大，所以，对于较小的图片，适合使用url-loader，对于较大的图片，还是使用file-loader比较好。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//配置的rules和file-loader及其相似。</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span><span class="token regex">/\.(jpg|gif|png)$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span><span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span><span class="token string">'url-loader'</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span><span class="token punctuation">{</span>                        name<span class="token punctuation">:</span><span class="token string">'[name]_[hash:8].[ext]'</span><span class="token punctuation">,</span>                        outputPath<span class="token punctuation">:</span><span class="token string">'images/'</span><span class="token punctuation">,</span>                        limit<span class="token punctuation">:</span><span class="token number">5000</span><span class="token comment" spellcheck="true">//这是和file-loader最主要的区别，url-loader在打包图片时，如果图片大小小于配置的limit值，就将图片传化位base64的字符串插入到打包的js文件中，如果大于limit，打包规则就和file-loader一致。所以也可以说url-loader是对file-loader更深层次的包装。</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="webpack处理样式相关的文件"><a href="#webpack处理样式相关的文件" class="headerlink" title="webpack处理样式相关的文件"></a>webpack处理样式相关的文件</h2><h3 id="打包css文件"><a href="#打包css文件" class="headerlink" title="打包css文件"></a>打包css文件</h3><ol><li><code>npm install style-loader css-loader -D</code></li><li>添加相应的规则</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.css/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//style-loader作用是生成一个&lt;style>&lt;style>标签插入在html文件中，css-loader作用是解析@import xxx.cs这种语法。</span></code></pre><h3 id="打包scss文件"><a href="#打包scss文件" class="headerlink" title="打包scss文件"></a>打包scss文件</h3><ol><li><code>npm install style-loader css-loader sass-loader</code></li><li>添加相应的规则</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.scss/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">,</span><span class="token string">'sass-loader'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>上述处理样式的文件的方法，都会吧css文件直接以<code>&lt;style&gt;</code>标签的形式插入到生成的html文件中，而如果我们希望将css文件打包后单曲抽离出来成为一个文件，且通过link标签的形式引入，就需要这样做：</p><h3 id="将css文件抽离出来成为一个单独的文件"><a href="#将css文件抽离出来成为一个单独的文件" class="headerlink" title="将css文件抽离出来成为一个单独的文件"></a>将css文件抽离出来成为一个单独的文件</h3><ol><li><code>npm install mini-css-extract-plugin -D</code>安装相应的插件</li><li>在配置文件中使用这个插件</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    filename<span class="token punctuation">:</span><span class="token string">'css/main.css'</span><span class="token comment" spellcheck="true">//将抽离出来的css文件会存放在打包时产生的bulid文件夹下的css文件夹下的main.css</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>3.将处理css和less文件的loader中的<code>style-loader</code>替换为<code>MiniCssExtractPlugin.loader</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.css$/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">[</span>MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.less$/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">[</span>MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">,</span><span class="token string">'less-loader'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="给css3属性加浏览器前缀"><a href="#给css3属性加浏览器前缀" class="headerlink" title="给css3属性加浏览器前缀"></a>给css3属性加浏览器前缀</h3><p>使用的loader是<code>postcss-loader</code>使用的插件是<code>autoprefixer</code></p><p>具体过程如下：</p><ol><li>安装相应的loader和插件</li><li>在根目录下建一个postcss.config.js，里面内容如下：</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">{</span>  plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'autoprefixer'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>将postcss-loader写在相应的rules里面。（写在处理css文件的css-loader的下面即可）</li></ol><h3 id="处理字体图标"><a href="#处理字体图标" class="headerlink" title="处理字体图标"></a>处理字体图标</h3><ol><li>在iconfont字体图标矢量库中选区自己需要的字体图标，下载代码到本地</li><li>将下载下来的代码中的字体文件和iconfont.css文件拷贝到项目中。</li><li>修改webpack.config.js的配置项，新增加一个匹配规则如下：</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.(svg|ttf|eot|woff)$/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token punctuation">{</span>            loader<span class="token punctuation">:</span><span class="token string">'file-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span><span class="token punctuation">{</span>                outputPath<span class="token punctuation">:</span><span class="token string">'./fonts'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="4"><li>在项目的index.css文件里通过<code>@import &#39;iconfont.css&#39;</code>的形式引入字体图标的样式文件。</li></ol><h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><p>作用：Plugin的直译是‘’插件‘’.Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。在webpack运行的生命周期中会广播出来许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。</p><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>作用：在打包结束之后，自动生成一个html文件，并将打包生成的js文件自动引入到这个html文件中。</p><p>使用方法：</p><ol><li>下载安装相应的插件<code>npm install html-webpack-plugin -D</code> </li><li>修改配置文件，添加plugins属性</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span><span class="token string">'./src/index.html'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//打包后自动生成的html文件的模板</span>            filename<span class="token punctuation">:</span><span class="token string">'index.html'</span><span class="token comment" spellcheck="true">//自动生成的html文件的名字</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p>作用：在每次打包之前都会将上一次打包生成的dist目录删除掉。</p><p>使用方法：</p><ol><li>安装相应的插件<code>npm install clean-webpack-plugin -D</code></li><li>修改配置文件，添加相应的plugin</li></ol><p><strong>注意</strong>：<br>每一次打包的结果中的hash值是随着打包源文件变化而变化的。如果要打包的源文件没有发生变化，那么打包结果的hash值也就不会有变化。但是实际上确实每一次都是删除了dist目录下的文件重新生成新的一份打包文件的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token punctuation">{</span>CleanWebpackPlugin<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在打包之前删除dist目录中的内容。</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="多入口情况处理"><a href="#多入口情况处理" class="headerlink" title="多入口情况处理"></a>多入口情况处理</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 多入口</span><span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        home<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>        other<span class="token punctuation">:</span> <span class="token string">'./src/other.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">"[name].js"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//这里的name就是entry里面的两个文件，可以是home，也可以是other</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        publicPath<span class="token punctuation">:</span>cdn地址<span class="token comment" spellcheck="true">//这里再打包完之后，会在html文件引入打包的js文件之前都加入这个cdn</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span> <span class="token string">'./index.html'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'home.html'</span><span class="token punctuation">,</span>            chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'home'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//表示home.html里面引入的是打包生成的home.js</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span> <span class="token string">'./index.html'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'other.html'</span><span class="token punctuation">,</span>            chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'other'</span><span class="token punctuation">,</span> <span class="token string">'home'</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// other.html 里面有 other.js &amp; home.js</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="souce-map的配置"><a href="#souce-map的配置" class="headerlink" title="souce-map的配置"></a>souce-map的配置</h2><p>作用：源码映射，用于在编码出错时，迅速找到源码的出错地址。</p><p>在module.exports导出的对象中加入<code>devtool: &#39;source-map&#39;</code> // 增加映射文件可以帮我们调试源代码</p><ol><li><code>「source-map」</code>：源码映射 会标识错误的代码 打包后生成独立的文件 大而全 出错了会标识当前出错的列和行</li><li><code>「evl-source-map」</code>：不会生成单独的文件 但是可以显示行和列  </li><li><code>「cheap-module-source-map」</code>：不会产生列，产生单独的映射文件 (生产环境线上推荐这个) </li><li><code>「cheap-module-eval-source-map」</code>：不会产生文件 集成在打包后的文件中 不会产生列 (开发环境推荐使用这个)</li></ol><h2 id="watch-监视打包文件，当需要打包的文件发生改变的时候，就自动重新打包"><a href="#watch-监视打包文件，当需要打包的文件发生改变的时候，就自动重新打包" class="headerlink" title="watch 监视打包文件，当需要打包的文件发生改变的时候，就自动重新打包"></a><code>watch</code> 监视打包文件，当需要打包的文件发生改变的时候，就自动重新打包</h2><pre class=" language-JavaScript"><code class="language-JavaScript">watch: true,watchOptions: {    poll: 1000,   // 每秒检查一次变动    aggregateTimeout: 300,  // 当第一个文件更改，会在重新构建前增加延迟（修改文件防抖）    ignored: /node_modules/  // 对于某些系统，监听大量文件系统会导致大量的 CPU 或内存占用。这个选项可以排除一些巨大的文件夹，},</code></pre><h2 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h2><p>安装：<code>npm install webpack-dev-server -D</code></p><p>配置时就是在module.exports导出的对象中添加一个devServer属性,具体情况如下所示：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//表示服务器起在这个目录下，因为我们打包生成的目录时dist，所以这里和其保持一致</span>        port<span class="token punctuation">:</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//表示服务器时开在3000端口上的</span>        open<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//自动打开浏览器，</span>        progress<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token comment" spellcheck="true">//在打包编译的过程中会有一个进度条效果</span>        proxy<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这个属性时用来做跨域的。</span>            <span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token string">'http://localhost:3000'</span><span class="token comment" spellcheck="true">//当前端的请求是以api开头的，就转到后面的这个地址上。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="webpack跨域配置"><a href="#webpack跨域配置" class="headerlink" title="webpack跨域配置"></a>webpack跨域配置</h2><p>常见的跨域有三种情况，下面分别介绍在这三种情况下如何配置webpack</p><h3 id="设置代理：这种情况下，会起一个后端服务"><a href="#设置代理：这种情况下，会起一个后端服务" class="headerlink" title="设置代理：这种情况下，会起一个后端服务"></a>设置代理：这种情况下，会起一个后端服务</h3><p>服务端采用express框架搭建，服务端代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>情况<span class="token number">1</span>：app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'GouKu'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>情况<span class="token number">2</span>：后端请求并不是以api开头app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'GouKu'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'app运行在3000端口上'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>；</code></pre><p>webpack默认端口是8080，所以可以在配置文件中设置一个代理</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span><span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span>        open<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//情况1：</span>        proxy<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token string">'http://localhost:3000'</span><span class="token comment" spellcheck="true">//表示如果前端i请求的路径是以api开头的，都转到3000这个端口上去。</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//情况2：在这种情况下，虽然前端依然请求的是api/user,但是经过代理之后，给后端发出的请求就是将api删掉了，实际向后端请求的是/user</span>          proxy<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                    target<span class="token punctuation">:</span><span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>                    reWritePath<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token string">'^/api'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">}</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>index.js中是这样写的</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这样每当请求的是以api开头的，就转到3000端口上去</span>xhr<span class="token punctuation">.</span>onload<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="只是前端去mock数据，并不涉及到后端"><a href="#只是前端去mock数据，并不涉及到后端" class="headerlink" title="只是前端去mock数据，并不涉及到后端"></a>只是前端去mock数据，并不涉及到后端</h3><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span>        before：<span class="token keyword">function</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//启用一个钩子函数</span>            app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'GouKu'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="有服务端且不使用代理，直接从服务端开启webpack"><a href="#有服务端且不使用代理，直接从服务端开启webpack" class="headerlink" title="有服务端且不使用代理，直接从服务端开启webpack"></a>有服务端且不使用代理，直接从服务端开启webpack</h3><ol><li>首先下载安装webpack的中间键<code>npm install webpack-dev-middleware -D</code></li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//server.js的内容如下：</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> middle <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-dev-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">middle</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'name'</span>：<span class="token string">"GouKu"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'app运行在3000端口上'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这样，在访问localhost：3000/api/user时也可以得到数据。    </span></code></pre><h2 id="热模块更新（hot-module-replacement-HMR）"><a href="#热模块更新（hot-module-replacement-HMR）" class="headerlink" title="热模块更新（hot module replacement HMR）"></a>热模块更新（hot module replacement HMR）</h2><p>使用热模块更新，可以在不刷新浏览器的情况下，只针对修改的文件做出样式活着是js上的变化。具体使用步骤如下：</p><ol><li>由于webpack自带着针对HMR的插件，所以，我们不必要再额外下载安装插件，只需要引入webpack即可。</li><li>在webpack.config.js中的devServer属性中添加上hot：true</li><li>在webpack.config.js中的plugins属性中实例化这个插件。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//setp1</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span>        port<span class="token punctuation">:</span><span class="token number">3000</span><span class="token punctuation">,</span>        progress<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>        open<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>        hot<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//step2</span>    <span class="token punctuation">}</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//step3</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p><strong>注意</strong>：</p><p>如果修改的是css文件，由于css-loader的关系，不需要在做额外的行为就可以针对修改的css样式浏览器做出反应，如果修改的是js文件，则需要在打包的入口文件中添加上以下代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span><span class="token punctuation">{</span>    module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>修改的js文件，（）<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>要执行的变化（业务代码）<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="webpack利用babel处理ES6语法"><a href="#webpack利用babel处理ES6语法" class="headerlink" title="webpack利用babel处理ES6语法"></a>webpack利用babel处理ES6语法</h2><ol><li>安装相应的loader</li></ol><p><code>npm install --save-dev babel-loader @babel/core</code></p><ol start="2"><li>在rules添加相应的规则</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span><span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span>test<span class="token punctuation">:</span><span class="token regex">/\.js$/</span><span class="token punctuation">,</span>exclude<span class="token punctuation">:</span><span class="token regex">/node_modules/</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span><span class="token string">'babel-loader'</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>在项目根路径下创建一个名字叫<strong>.babelrc</strong>的文件，里面的内容为</li></ol><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"preset"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p><strong>注意</strong>：上述做法是babel官网的教程，但是这样的做法是不全面的，更全面的做法是，在上述基础上，接着如下操作：</p><ol start="4"><li>安装babel/polyfill  <code>npm install --save @babel/polyfill</code></li><li>在打包的入口js文件导入babel/polyfill <code>import &quot;@babel/polyfill&quot;;</code>这样其实就可以了，但是打包出来的js文件会非常大，所以还需要第6步的优化</li><li>修改.babelrc文件为：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    <span class="token string">"preset"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span><span class="token punctuation">{</span>         targets<span class="token punctuation">:</span> <span class="token punctuation">{</span>            edge<span class="token punctuation">:</span> <span class="token string">"17"</span><span class="token punctuation">,</span>            firefox<span class="token punctuation">:</span> <span class="token string">"60"</span><span class="token punctuation">,</span>            chrome<span class="token punctuation">:</span> <span class="token string">"67"</span><span class="token punctuation">,</span>            safari<span class="token punctuation">:</span> <span class="token string">"11.1"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//target里面写的内容是这些版本及以上的的浏览器对ES6语法都做了很好的兼容，所以，不需要再ployfill，就可以减少打包文件的体积。</span>        useBuiltIns<span class="token punctuation">:</span> <span class="token string">'usage'</span><span class="token comment" spellcheck="true">//只有用到的ES6语法方案才会被注入。</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><hr><p><strong>注意</strong>：上述的关于babel在webpack上的配置都是用来处理业务代码的，如果在实际开发中我们需要开发的是js类库这种不需要污染全局变量的化，就不能使用babel/polyfill了，而是要采用以下配置</p><ol><li>不需要在入口文件引入<code>import &quot;@babel/polyfill</code></li><li><code>npm install --save-dev @babel/plugin-transform-runtime</code></li><li><code>npm install --save @babel/runtime</code></li><li>修改.babelrc文件如下：</li></ol><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"absoluteRuntime"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"corejs"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token property">"helpers"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"regenerator"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"useESModules"</span><span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="5"><li>此时打包的时候会报错，是因为还需要再<code>npm install --save @babel/runtime-corejs2</code>这样就不会报错了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2019/06/25/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/06/25/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载DOM,渲染–&gt;更新–&gt;渲染，销毁等一系列过程，也就是Vue实例从创建到销毁的过程，就是生命周期。</p><p><img src="/2019/06/25/Vue生命周期/lifecycle.png" alt></p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是一个vue实例的第一个生命周期函数，在这个阶段，vue实例上的data中的数据和methods中的方法都不可以使用。</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是一个vue实例的第二个生命周期函数，要想使用vue实例上的data中的数落和methods中的方法，最早只能够在此阶段。在这里更改数据不会触发updated函数。</span><span class="token number">3</span><span class="token punctuation">.</span><span class="token function">beforemount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是一个vue实例的第三个生命周期函数，在此阶段，已经在内存中生成了虚拟DOM树，但是尚未挂载到页面上，所以，此时页面上的元素中的数据还没有真正的替换过来，所以里面的内容还是之前写的插值表达式。</span><span class="token number">4</span><span class="token punctuation">.</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是一个vue实例的第四个生命周期函数，也是vue实例创建阶段的最后一个生命函数，在这个阶段，模板已经挂载到了页面上，数据也进行了替换，不再是插值表达式。如果想要操作DOM元素，最早可在该阶段进行。</span></code></pre><h3 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是运行阶段的第一个生命周期函数，在vue实例中data中的数据发生改变的时候才会触发，但是，在这个阶段，虽然data中的数据已经改变，页面中的数据还是尚未改变的数据，此时，页面还没有同步新的数据。</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//但是，在这个阶段，data中的数据已经改变，页面中的数据已经改变，此时，页面已经同步新的数据。</span></code></pre><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">beforeDestory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在这个阶段，vue实例中的data中的数据和methods中的方法尚可以使用。</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token function">destoryed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在这个阶段,vue实例已经被销毁了。解绑它的全部指令及事件监听器，并不会清除data的数据或者清除dom。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消除浮动</title>
      <link href="/2019/06/24/%E6%B6%88%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2019/06/24/%E6%B6%88%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>当父盒子没有定义高度，嵌套的盒子浮动之后，下边的元素的位置会发生错误。因此要消除由于浮动而产生的不利影响。</p><h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><p>在最后一个浮动元素后面添加标签</p><pre class=" language-css"><code class="language-css">&lt;div class=<span class="token string">'content'</span>>    &lt;div class=<span class="token string">'content'</span>>&lt;/div>    &lt;div class=<span class="token string">'siderbar'</span>>&lt;/div>    &lt;div style=<span class="token string">'claer:both'</span>>&lt;/div>//这个就是额外的标签&lt;/div></code></pre><h2 id="给父盒子使用overflo：hidden"><a href="#给父盒子使用overflo：hidden" class="headerlink" title="给父盒子使用overflo：hidden"></a>给父盒子使用overflo：hidden</h2><p><strong>注意</strong>：如果父盒子包裹的内容出了盒子，则不能使用这个方法，因为出了范围的内容会消失不见。</p><h2 id="伪元素清除浮动"><a href="#伪元素清除浮动" class="headerlink" title="伪元素清除浮动"></a>伪元素清除浮动</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.clear</span> <span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">visiblity</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span><span class="token punctuation">}</span>//想要使得<span class="token property">clear</span><span class="token punctuation">:</span>both生效的元素必须时块级元素，conten属性必须要有，有了之后为元素才可以生效。//引用的时候给父元素添加clear这个类即可。&lt;div class=<span class="token string">'father clear'</span>>&lt;/div></code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2019/06/21/DNS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/21/DNS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>域名系统(Domain Name System)</strong>是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。<strong>不管哪个本地域名服务器，如果要对互联网上任何一个域名进行解析，只要自己无法解析，就首先要求助根域名服务器。</strong></p><p>根域名服务器并不直接把待查询的域名直接转换成IP地址。而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</p><h3 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h3><p>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答。(可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址)。</p><h3 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h3><p>当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>主机向本地域名服务器查询一般都采用<strong>递归查询</strong>。所谓递归查询就是:如果主机所查询的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份。向其他根域名服务器继续发出查询请求报文。而不是让该主机进行下一步查询。</p><p>本地域名服务器向根域名服务器的查询一般时采用<strong>迭代查询</strong>。迭代查询的特点是：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询。然后让本地域名服务器进行后续查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再去向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所有查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。本地域名服务器就这样迭代查询。</p><h3 id="浏览器解析DNS的过程"><a href="#浏览器解析DNS的过程" class="headerlink" title="浏览器解析DNS的过程"></a>浏览器解析DNS的过程</h3><ol><li>浏览器首先会搜索自身的DNS缓存，(缓存时间较短，默认只有1min，而且只能存1000条缓存)</li><li>如果浏览器自身缓存没有找到对应的条目，就会搜索操作系统自身的DNS缓存。</li><li>如果在系统的DNS缓存也没有找到，就尝试读取<code>host</code>文件。看看这里面有没有该域名对应的IP地址。</li><li>如果<code>host</code>文件也没有找到对应的条目，浏览器就发起一个DNS调用，请求本地域名服务器来解析这个域名。</li><li>如果本地域名服务器没有命中，就直接向根域名服务器请求解析。</li><li>根域名服务器返回给本地域名服务器一个所查询的顶级域名服务器。</li><li>本地域名服务器再向上一步返回的顶级域名服务器发送请求。</li><li>接收请求的顶级域名服务器查找并返回此域名对应的<code>Name Server</code>域名服务器的地址。这个<code>Name Server</code>通常就是用户注册的域名服务器。</li><li><code>Name Server</code>域名服务器会查询存储的域名和IP的映射关系表。</li><li>返回该域名对应的IP</li><li>把解析结果返回给用户。</li></ol><h3 id="CDN解析过程"><a href="#CDN解析过程" class="headerlink" title="CDN解析过程"></a>CDN解析过程</h3><ol><li>用户向本地域名服务器发起查询请求。</li><li>本地域名服务器迭代向根域名服务器查询，逐级迭代。rootDNS–&gt;顶级DNS–&gt;权限DNS</li><li>获得权限DNS之后，本地域名服务器向权限DNS发起域名解析请求。</li><li>权限DNS通常会将域名CNAME到另一个域名，这个域名最终会被指向CDN网络中的智能DNS负载均衡系统。</li><li>DNS负载均衡系统通过一些智能算法，将最合适的CDN节点IP返回给本地域名服务器。</li><li>本地域名服务器将获得都IP地址返回给用户。</li><li>用户得到节点都IP地址后，向该节点发起访问请求。</li><li>CDN节点返回请求文件，如果该节点中请求的文件不存在，就会再回到源站获取这个文件，然后返回给用户。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当promise遇到Event Loop</title>
      <link href="/2019/06/12/%E5%BD%93promise%E9%81%87%E5%88%B0Event%20Loop/"/>
      <url>/2019/06/12/%E5%BD%93promise%E9%81%87%E5%88%B0Event%20Loop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近一段时间再复习Event loop的时候，遇到promise，以及混合着async/await！！！简直是要了我的小命。正当我一筹莫展之际，有幸读到一篇掘金社区上此类问题的文章：<a href="https://juejin.im/post/5c9a43175188252d876e5903" target="_blank" rel="noopener">Eventloop不可怕，可怕的是遇上Promise</a>顿时觉得醍醐灌顶。故与诸君分享。</p></blockquote><h2 id="Easy-Mode："><a href="#Easy-Mode：" class="headerlink" title="Easy Mode："></a>Easy Mode：</h2><blockquote><p>​    来试一下这个开胃菜。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> </code></pre><p><strong>体会</strong>：简单考题。考察eventloop的执行顺序以及宏任务和微任务。输出结果是：[3,2,1]</p><h2 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h2><blockquote><p>​    第一题是不是不难？那第二题也不难呀！</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">let</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> </code></pre><p><strong>体会</strong>：考察eventloop和promise.then的执行方式。先上结果:[2,5,3,4,1]。由一点需要注意的是：<strong>Promise的链式调用then，每次都会在内部生成一个新的Promise，然后执行then，在执行的过程中不断向微任务(microtask)推入新的函数，因此直至微任务(microtask)的队列清空后才会执行下一波的macrotask。</strong></p><h2 id="Hard-Mode"><a href="#Hard-Mode" class="headerlink" title="Hard Mode"></a>Hard Mode</h2><blockquote><p>I promise。。。。这道题一点都不难</p></blockquote><h3 id="round-1"><a href="#round-1" class="headerlink" title="round 1"></a>round 1</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then11"</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then21"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then23"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then12"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这个是在第二个例子上的改进。主要体现在再promise.then中又创建了一个promise。MMP 还能不能愉快的玩耍了？你在这玩俄罗斯套娃呢？</p><p>吐槽归吐槽，言归正传，遇到这种嵌套的Promise时不要慌(废话，我现在岂止是慌，我慌的一匹。)。首先心中要有一个队列，能够将这些函数放到相应的队列中去问题就迎刃而解了。</p><p><strong>第一轮</strong>：</p><p>输出：promise1</p><p>micro task queue：[promise1的第一个then]</p><p><strong>第二轮</strong>：</p><p>输出：then11，prmoise2</p><p>micro task queue:[prmosie2的第一个then，promise1的第二个then]</p><p><strong>第三轮</strong>：</p><p>输出：then21,then12</p><p>micro task quque:[promise2的第二个then]</p><p><strong>第四轮</strong>：</p><p>输出：then 23</p><h3 id="round-2"><a href="#round-2" class="headerlink" title="round 2"></a>round 2</h3><p>那如果说这边的Promise中then返回一个Promise呢？？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then11"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then21"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then23"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"then12"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>我看你就是在为难我胖虎。这个考的重点是<strong>promise返回一个promise的时候，then12相当于是挂载了新的promise的最后一个then的返回值上。</strong>所以结果是：[promise1,then11,promise2,then21,then23,then12]</p><h3 id="round-3"><a href="#round-3" class="headerlink" title="round 3"></a>round 3</h3><p>那要是多来几个promise呢？</p><pre class=" language-JavaScript"><code class="language-JavaScript">new Promise((resolve,reject)=>{    console.log("promise1")    resolve()}).then(()=>{    console.log("then11")    new Promise((resolve,reject)=>{        console.log("promise2")        resolve()    }).then(()=>{        console.log("then21")    }).then(()=>{        console.log("then23")    })}).then(()=>{    console.log("then12")})new Promise((resolve,reject)=>{    console.log("promise3")    resolve()}).then(()=>{    console.log("then31")})</code></pre><p>你这是想让我死。哎，有什么办法呢？来吧：</p><p><strong>第一轮</strong>：</p><p>输出：promise1，promise3</p><p>micro task queue:[promise1的第一个then，promise3的then]</p><p><strong>第二轮</strong>：</p><p>输出：then11,promise2,then31</p><p>micro task queue:[promise2的第一个then，prmosie1的第一个then]</p><p><strong>第三轮</strong>：</p><p>输出：then21，then12</p><p>micro task queue:[promise2的第二个then]</p><p><strong>第四轮</strong>：</p><p>输出：then 23</p><h2 id="Master-Mode"><a href="#Master-Mode" class="headerlink" title="Master Mode"></a>Master Mode</h2><blockquote><p>你头伸过来，给你看看async/await这个好东西</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async1 start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span>  <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async1 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span>  <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">'async2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"script start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"settimeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p><strong>考察在async/await之下，对Eventloop的影响。</strong></p><p>async/await仅仅影响的是函数内的执行，而不会影响到函数体外的执行顺序。也就是说async1()并不会阻塞后续程序的执行，<code>**await async2()</code>相当于一个Promise，<code>console.log(&quot;async1 end&quot;);</code>相当于前方Promise的then之后执行的函数。**</p><p>输出结果：[script start,async1 start,async2,promise1,script end,async1 end,promise2,settimeout]</p><h2 id="Hell-mode"><a href="#Hell-mode" class="headerlink" title="Hell mode"></a>Hell mode</h2><blockquote><p>小伙子，不错嘛，前四轮都挺过来了，一看就是个骨骼精奇的人。来来来，尝尝这大碗宽面。不不不，大杂烩。这是我毕生的功力了！</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async1 start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span>  <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async1 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span>  <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">'async2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"script start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"settimeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setImmediate"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"process"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>F**K。你能不能要点脸。你已经不是想让我死了。你是想让我永世不得超生。</p><p><strong>第一轮</strong>：</p><p>输出:[script start,async1 start,async2,promise1,script end]</p><p>macro task queue:[setTimeout,setImmediate]</p><p>micro task quequ:[process.nextTick,async2的promise.then,Promise.then]</p><p><strong>因为nextTick优先级高于promise.then的优先级</strong>。</p><p><strong>第二轮</strong>：</p><p>输出：[process,async1 end,promise2]</p><p>macro task quequ:[setTimeout,setImmediate]</p><p>micro task queue:[];</p><p><strong>第三轮</strong>：</p><p>输出：settimeout</p><p>macro task quequ:[setImmediate]</p><p>micro task queue:[];</p><p><strong>第四轮</strong>：</p><p>输出：setImmediate</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2019/06/09/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2019/06/09/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>当持续触发事件时，一定时间段内没有再触发时间，时间处理函数才会执行一次，如果设定的时间到来之前，有一次触发了事件，就重新开始延时。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>timeout <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 处理函数</span>    <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我被点击了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 滚动事件</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>注</strong>：这个按钮所注册的点击事件只有在1s之内没有再次点击该按钮才会执行弹框，如果点击了按钮之后1s之内再次点击按钮，则会以第二次按钮点击的时间为基准，往后延迟1s后执行。</p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>当持续触发时间时，保证一定时间段内只调用一次时间处理函数。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token number">1</span><span class="token punctuation">.</span> 使用时间戳实现    <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span>duration<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> lastTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-</span>lastTime<span class="token operator">></span>duration<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token number">2</span><span class="token punctuation">.</span>使用定时器实现    <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> timeOutId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timeOutId<span class="token punctuation">)</span><span class="token punctuation">{</span>                    timeOutId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        timeOutId <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">await</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行了一次'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span></code></pre><p><strong>注</strong>：这个按钮的点击事件无论点击多少次，1s内只执行一次。</p><h2 id="函数防抖与函数节流的区别"><a href="#函数防抖与函数节流的区别" class="headerlink" title="函数防抖与函数节流的区别"></a>函数防抖与函数节流的区别</h2><p>防抖的函数不保证一段时间内执行一次，如果再该段时间里面该事件持续被触发，那么这个事件永远不会执行。</p><p>函数节流则时一段事件内无论触发多少次事件，都只会响应一次该事件。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染过程</title>
      <link href="/2019/06/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/06/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="关键路径渲染"><a href="#关键路径渲染" class="headerlink" title="关键路径渲染"></a>关键路径渲染</h2><p><strong>浏览器接收到服务器返回的HTML、CSS和JavaScript字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径</strong></p><p><strong>浏览器在渲染页面前需要先构建出DOM树与CSSOM树</strong>（如果没有<code>DOM</code>树和<code>CSSOM</code>树就无法确定页面的结构与样式，所以这两项是必须先构建出来的）。</p><p><strong>DOM树全称为Document Object Model文档对象模型，它是HTML和XML文档的编程接口，提供了对文档的结构化表示，并定义了一种可以使程序对该结构进行访问的方式</strong>（比如<code>JavaScript</code>就是通过<code>DOM</code>来操作结构、样式和内容）。<code>DOM</code>将文档解析为一个由节点和对象组成的集合，可以说一个<code>WEB</code>页面其实就是一个<code>DOM</code>。</p><p><code>CSSOM</code>树全称为<code>Cascading Style Sheets Object Model</code>层叠样式表对象模型，它与<code>DOM</code>树的含义相差不大，只不过它是<code>CSS</code>的对象集合。</p><h2 id="构建DOM树和CSSOM树"><a href="#构建DOM树和CSSOM树" class="headerlink" title="构建DOM树和CSSOM树"></a>构建DOM树和CSSOM树</h2><p>浏览器从网络或硬盘中获得<code>HTML</code>字节数据后会经过一个流程将字节解析为<code>DOM</code>树：</p><ol><li>编码： <strong>先将HTML的原始字节数据转换为文件指定编码的字符。</strong></li><li>令牌化： 然后<strong>浏览器会根据HTML规范来将字符串转换成各种令牌</strong>（如<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有<code>&lt;html&gt;</code>与<code>&lt;body&gt;</code>两个标签，当<code>&lt;html&gt;</code>标签的令牌还未遇到它的结束令牌<code>&lt;/html&gt;</code>就遇见了<code>&lt;body&gt;</code>标签令牌，那么<code>&lt;body&gt;</code>就是<code>&lt;html&gt;</code>的子标签）。</li><li>生成对象： <strong>接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。</strong></li><li>构建完毕： <strong>DOM树构建完成，整个对象集合就像是一棵树形结构</strong>。</li></ol><p>整个<code>DOM</code>树的构建过程其实就是： <strong>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型</strong></p><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>在构建了<code>DOM</code>树和<code>CSSOM</code>树之后，浏览器只是拥有了两个互相独立的对象集合，<code>DOM</code>树描述了文档的结构与内容，<code>CSSOM</code>树则描述了对文档应用的样式规则，<strong>想要渲染出页面，就需要将DOM树与CSSOM树结合在一起</strong>，这就是渲染树。</p><ol><li>浏览器会先从<code>DOM</code>树的根节点开始遍历每个可见节点</li><li>对每个可见节点，找到其适配的<code>CSS</code>样式规则并应用。</li><li>渲染树构建完成，每个节点都是可见节点并且都含有其内容和对应规则的样式</li></ol><p>渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则<strong>需要计算每个节点在窗口内的确切位置与大小，也就是布局阶段。</strong></p><p><strong>布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置</strong>，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值。</p><p><strong>总结</strong>：</p><p>总结一下浏览器关键渲染路径的整个过程：</p><ol><li>处理<code>HTML</code>标记数据并生成<code>DOM</code>树。</li><li>处理<code>CSS</code>标记数据并生成<code>CSSOM</code>树。</li><li>将<code>DOM</code>树与<code>CSSOM</code>树合并在一起生成渲染树</li><li>遍历渲染树开始布局，计算每个节点的位置信息。</li><li>将每个节点绘制到屏幕。</li></ol>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化常用总结</title>
      <link href="/2019/06/09/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2019/06/09/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="网络方面"><a href="#网络方面" class="headerlink" title="网络方面"></a>网络方面</h2><p>web应用，总有一部分时间浪费在网络连接和资源下载上。往往建立一次网络连接是需要花费时间成本的，而浏览器同一时间发送的网络请求的数目总是有限的，所以，这个层面上的优化可以从<strong>减少请求数目</strong>开始</p><h3 id="减少请求数目"><a href="#减少请求数目" class="headerlink" title="减少请求数目"></a>减少请求数目</h3><ol><li>合并js文件</li><li>合并css文件</li><li>使用css sprite </li><li>对于一些小的图片使用base64来表示</li></ol><p>前两个可以通过webpack这种打包工具来进行打包，精灵图有专门的制作工具。webpack也有将图片转为base64的插件。</p><h3 id="减少资源体积"><a href="#减少资源体积" class="headerlink" title="减少资源体积"></a>减少资源体积</h3><ol><li>html文件压缩</li><li>js文件压缩</li><li>css文件压缩</li><li>图片压缩</li></ol><h3 id="优化缓存"><a href="#优化缓存" class="headerlink" title="优化缓存"></a>优化缓存</h3><ol><li>DNS缓存</li><li>CDN部署和缓存</li><li>http缓存</li></ol><p>由于浏览器会在DNS解析步骤中消耗一定的时间，所以对于一些高访问量都网站来说，做好DNS的缓存工作，会一定程度上提高网站效率。</p><p>CDN作为静态资源文件分发的网络，本身就已经提升了网站静态资源获取的速度，加快了网站的加载速度。</p><p>http缓存：给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复下载，从而提升</p><h2 id="渲染和DOM操作方面"><a href="#渲染和DOM操作方面" class="headerlink" title="渲染和DOM操作方面"></a>渲染和DOM操作方面</h2><h3 id="优化网页渲染"><a href="#优化网页渲染" class="headerlink" title="优化网页渲染"></a>优化网页渲染</h3><ol><li>css文件放在头部，js文件放在尾部或者是异步加载</li><li>尽量避免内联样式。</li></ol><p>css文件放在头部加载，可以保证在解析DOM的同时，解析css文件。因为CSS会阻塞整个DOM的渲染，但是不会阻塞DOM的解析。所以将css文件放在头部进行解析，可以加快网页的构建速度。假设将其放在尾部，那时DOM树几乎构建，这时就得等到CSSOM树构建完成，才能够继续下面的步骤。</p><p>js放在尾部：js文件不同，将js文件放在尾部或者异步加载的原因是JS（外链或内联）会阻塞后续DOM的解析，后续DOM的渲染也将被阻塞，而且一旦js中遇到DOM元素的操作，很可能会影响。</p><h3 id="DOM操作的优化"><a href="#DOM操作的优化" class="headerlink" title="DOM操作的优化"></a>DOM操作的优化</h3><ol><li>尽量避免重排和重绘。</li><li>使用事件代理</li><li>函数防抖和函数节流</li></ol><h2 id="数据方面"><a href="#数据方面" class="headerlink" title="数据方面"></a>数据方面</h2><h3 id="图片加载处理"><a href="#图片加载处理" class="headerlink" title="图片加载处理"></a>图片加载处理</h3><ol><li>图片懒加载</li><li>图片预加载</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2019/06/08/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/06/08/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>flex布局是css3中新增加的一种布局方式，也叫做弹性盒子模型。用来为盒状模型提供最大的灵活性。Flex布局有两层，采用flex布局的元素称为<strong>flex容器</strong>，其子元素则自动成为flex item 即<strong>项目</strong>。flex内部的元素具有伸缩性,可按照设置的比例决定元素的宽高。flex最大的特点就是布局方便，简单，而且有较好的自适应能力。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><strong>作用</strong>：决定主轴的方向。</p><p><strong>取值</strong>：</p><ol><li><code>row(默认值)</code>：主轴为水平方向，起点在容器的左端</li><li><code>row-reverse</code>:主轴为水平方向，起点在容器的右端</li><li><code>column</code>:主轴为垂直方向，起点为容器的顶端</li><li><code>column-reverse</code>:主轴为垂直方向，起点为容器的底端</li></ol><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><strong>作用</strong>：如果一条轴线排不下所有内容该如何换行</p><p><strong>取值</strong>：</p><ol><li><code>nowrap(默认值)</code>：不换行</li><li><code>wrap</code> :换行，和书写方式一样，第一行在第二行的上方</li><li><code>wrap-reverse</code>:换行，第一行在第二行的下方</li></ol><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><strong>作用</strong>：定义了项目在主轴上的对齐方式</p><p><strong>取值</strong>：</p><ol><li><code>flex-start(默认值)</code>:从主轴开始的地方</li><li><code>flex-end</code>:从主轴结束的地方</li><li><code>center</code>:居中对齐</li><li><code>space-between</code>:两端对齐，项目之间的间隔相等</li><li><code>space-round</code>:每个项目之间的距离相等</li></ol><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><strong>作用</strong>：定义了项目在侧轴上的对齐方式</p><p><strong>取值</strong>：</p><ol><li><code>flex-start</code>:从侧轴开始的地方，一半是容器的顶部</li><li><code>flex-end</code>:从侧轴结束的地方</li><li><code>center</code>:居中对齐</li><li><code>baseline</code>:沿着项目第一行文字的基线对齐</li><li><code>stretch</code>(默认取值):如果项目没有设置高度，则占满整个容器的高度</li></ol><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><strong>作用</strong>：定义项目的放大比例，默认值是0，表示即使存在剩余空间，也不会放大</p><p><strong>注意</strong>：如果所有项目的<code>flex-grow</code>属性都为1，则他们将均分剩余的空间，如果有一个项目的<code>flex-grow</code>为2，其他项目为1，则前者的所占的剩余空间是其余项的一倍</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><strong>作用</strong>：定义项目的缩小比例，默认值是1，表示即使空间不够，也不去缩放</p><p><strong>注意</strong>：如果所有项目的<code>flex-shrink</code>都为1，当空间不足时，他们将等比例缩放，如果一个项目的<code>flex-shrink</code>为0，而其余的为1时，如果空间不够，前者不缩放。<strong>负值对该属性无效</strong></p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><strong>作用</strong>：定义了在分配多余空间之前，项目所占据的主轴空间。浏览器根据这个属性，计算是否还有剩余空间。它可以设置为和width一样的具体的值，表示一个固定的值。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><strong>作用</strong>:这个属性是<code>flex-grow</code>，<code>flex-shrink</code>,<code>flex-basis</code>的简写，默认值是<code>0 1 auto</code>,其中后两个属性是可选的。    </p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC</title>
      <link href="/2019/06/08/cssBFC/"/>
      <url>/2019/06/08/cssBFC/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC(Block Formatting Context)：格式化上下文，是Web页面中盒模型布局的css渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。它决定了其子元素如何定位，以及与其他元素的相互作用关系。</p><h2 id="BFC的生成"><a href="#BFC的生成" class="headerlink" title="BFC的生成"></a>BFC的生成</h2><p>满足下列CSS声明之一的元素就会生成BFC</p><ol><li>根元素或者其他包含它的元素</li><li>float的值不为none</li><li>overflow不为visible的值</li><li>position为absolute或者fixed的</li><li>display的值为inline-block，table-cell，table-caption</li><li>元素的display为flex或者inline-flex</li></ol><h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2><ol><li>内部的元素会在垂直方向一个接一个的排列，可以理解为是BFC中的一个常规流</li><li>元素垂直方向的距离由margin决定，即同属于一个BFC的两个相邻的盒子的margin可能会发生重叠</li><li>每个元素的左外边距与包含块的左外边距相接触，即使存在浮动的情况下也是如此，这说明BFC的子元素不会超出它的包含块</li><li>BFC区域不会与float元素区域重叠</li><li>计算BFC高度的时候，浮动的子元素也参与计算.</li><li>BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="解决margin塌陷"><a href="#解决margin塌陷" class="headerlink" title="解决margin塌陷"></a>解决margin塌陷</h3><h3 id="清除浮动问题"><a href="#清除浮动问题" class="headerlink" title="清除浮动问题"></a>清除浮动问题</h3><h3 id="解决侵占浮动元素的问题——-gt-两栏布局"><a href="#解决侵占浮动元素的问题——-gt-两栏布局" class="headerlink" title="解决侵占浮动元素的问题——-&gt;两栏布局"></a>解决侵占浮动元素的问题——-&gt;两栏布局</h3><p>浮动的元素会脱离文档流，然后覆盖在文档流元素上，当一个元素浮动，另外一个不浮动的时候，浮动的元素会因为脱离文档流而盖在不浮动的元素上。所以我们为非浮动元素建立BFC环境，根据BFC的不和float box重叠的规则，就会解决侵占元素问题。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS控制前端图片HTTP请求的情况</title>
      <link href="/2019/06/06/CSS%E6%8E%A7%E5%88%B6%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%83%85%E5%86%B5/"/>
      <url>/2019/06/06/CSS%E6%8E%A7%E5%88%B6%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="隐藏图片"><a href="#隐藏图片" class="headerlink" title="隐藏图片"></a>隐藏图片</h2><pre><code>&lt;img src=&#39;xxx.jpg&#39; style=&#39;display:none&#39;&gt;</code></pre><p><strong>结论</strong>：产生HTTP请求，此外使用visiblity：hidden的时候也会产生请求。</p><h2 id="重复图片"><a href="#重复图片" class="headerlink" title="重复图片"></a>重复图片</h2><pre><code>&lt;img src=&#39;xxx.jpg&#39;&gt;&lt;img src=&#39;xxx.jpg&#39;&gt;</code></pre><p><strong>结论</strong>：所有浏览器对重复的资源都只发出一次请求。</p><h2 id="重复背景"><a href="#重复背景" class="headerlink" title="重复背景"></a>重复背景</h2><pre><code>&lt;style&gt;    .test1{background:url(xxx.jpg)}    .test2{background:url(xxx.jpg)}&lt;&#x2F;style&gt;&lt;div class=&#39;test1&#39;&gt;&lt;&#x2F;div&gt;&lt;div class=&#39;test2&#39;&gt;&lt;&#x2F;div&gt;</code></pre><p><strong>结论</strong>：所有浏览器都只发出一次HTTP请求</p><h2 id="不存在的元素的背景"><a href="#不存在的元素的背景" class="headerlink" title="不存在的元素的背景"></a>不存在的元素的背景</h2><pre><code>&lt;style&gt;    .test1{background:url(xxx.jpg)}    .test2{background:url(xxx.png)}&lt;&#x2F;style&gt;&lt;div class=&#39;test1&#39;&gt;&lt;&#x2F;div&gt;</code></pre><p><strong>结论</strong>：背景仅在应用的元素在页面中存在的时候，才会发出请求。</p><h2 id="隐藏元素的背景"><a href="#隐藏元素的背景" class="headerlink" title="隐藏元素的背景"></a>隐藏元素的背景</h2><pre><code>&lt;style&gt;    .test1{        background:url(xxx.jpg);        display:none;    }    .test2{background:url(xxx.png)}&lt;&#x2F;style&gt;&lt;div class=&#39;test1&#39;&gt;&lt;&#x2F;div&gt;</code></pre><p><strong>结论</strong>：Chrome会为display：none；的元素发出请求，但是fireFox和opera不会为display：none；的元素发出HTTP请求。</p><h2 id="多重背景"><a href="#多重背景" class="headerlink" title="多重背景"></a>多重背景</h2><pre><code>&lt;style&gt;    .test1{        background:url(xxx.jpg);    }    .test1{background:url(xxx.png)}&lt;&#x2F;style&gt;&lt;div class=&#39;test1&#39;&gt;&lt;&#x2F;div&gt;</code></pre><p><strong>结论</strong>：因为下面的样式把上面的掩盖掉，所以只会发出一次HTTP请求。</p><h2 id="hover的背景加载"><a href="#hover的背景加载" class="headerlink" title="hover的背景加载"></a>hover的背景加载</h2><pre><code>&lt;style&gt;    .test1{        background:url(xxx.jpg);    }    .test1:hover{background:url(xxx.png)}&lt;&#x2F;style&gt;&lt;div class=&#39;test1&#39;&gt;&lt;&#x2F;div&gt;</code></pre><p><strong>结论</strong>：触发hover时，才会有对应的HTTP请求，如果没有触发，默认只会有请求默认的背景图片</p><h2 id="JS中innerHTML中的图片"><a href="#JS中innerHTML中的图片" class="headerlink" title="JS中innerHTML中的图片"></a>JS中innerHTML中的图片</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;       var el = document.createElement(&#39;div&#39;);       el.innerHTML = &#39;&lt;img src=&quot;haorooms.jpg&quot; /&gt;&#39;;   &lt;/script&gt;  </code></pre><p><strong>结论</strong>：只有Opera不会立刻发出请求，其余浏览器会发出HTTP请求。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的各种单位</title>
      <link href="/2019/06/06/CSS%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D/"/>
      <url>/2019/06/06/CSS%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">单位</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">px</td><td style="text-align:center">绝对单位，页面按照精确像素显示。</td></tr><tr><td style="text-align:center">em</td><td style="text-align:center">相对单位，基准点为父节点字体的大小，如果自身定义了font-size，则以自身字体大小来计算 。</td></tr><tr><td style="text-align:center">rem</td><td style="text-align:center">相对单位，可以理解为root em，根据页面根节点HTML的字体大小来计算。</td></tr><tr><td style="text-align:center">vw</td><td style="text-align:center">viewpoint width 视窗宽度，1vw等于视窗宽度的1%。</td></tr><tr><td style="text-align:center">vh</td><td style="text-align:center">viewpoint height 视窗高度，1wh等于视窗高度的1%。</td></tr><tr><td style="text-align:center">vmin</td><td style="text-align:center">vh和vw中较小的一个。</td></tr><tr><td style="text-align:center">vmax</td><td style="text-align:center">vh和vw中较大的一个。</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">百分比。</td></tr><tr><td style="text-align:center">in</td><td style="text-align:center">寸。</td></tr><tr><td style="text-align:center">cm</td><td style="text-align:center">厘米。</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">毫米。</td></tr><tr><td style="text-align:center">pt</td><td style="text-align:center">point 大约1/72寸。</td></tr><tr><td style="text-align:center">ex</td><td style="text-align:center">取当前作用效果的字体的x字符的高度，在无法确定的情况下为0.5em。</td></tr><tr><td style="text-align:center">ch</td><td style="text-align:center">取当前作用效果的字体的0字符的高度，在无法确定的情况下为0.5em。</td></tr></tbody></table><blockquote><p><strong>em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小</strong></p></blockquote><pre class=" language-javascript"><code class="language-javascript">  <span class="token punctuation">.</span>p1 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 16px<span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token punctuation">:</span> 32px<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span>s1 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span>s2 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span>p2 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 16px<span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span>s5 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">.</span>s6 <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span> line<span class="token operator">-</span>height<span class="token punctuation">:</span> 2em<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"p1"</span><span class="token operator">></span>       <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"s1"</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>       <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"s2"</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"p2"</span><span class="token operator">></span>       <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"s5"</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>       <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"s6"</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment" spellcheck="true">//此时s1的字体大小为32px,行高由于自身没有设置，所以是从父元素继承，所以也是32px</span><span class="token comment" spellcheck="true">//s2的字体大小为32px，行高设置为2em，因为自身有设置字体，所以行高是针对自身的字体高度，所以行高是64px</span><span class="token comment" spellcheck="true">//s5的字体是32px，因为行高是继承而来的，即line-height:2;所以实际行高是32*2 = 64px</span><span class="token comment" spellcheck="true">//s6的字体是32px,行高是2em，所以是2*32 = 64px。</span></code></pre><h2 id="rem布局原理"><a href="#rem布局原理" class="headerlink" title="rem布局原理"></a>rem布局原理</h2><p>rem布局的本质是等比缩放，一般是基于宽度的。假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示,即x=屏幕宽度/100，如果将x作为单位，x前面的数值就代表屏幕宽度的百分比。</p><p>如果想要页面元素随着屏幕宽度等比例变化，我们需要上面所讲的x单位，通过css中的rem，可以实现这个x。</p><p>如何让html字体大小一直等于屏幕宽度的百分之一呢？可以通过js来设置，一般需要在dom ready，resize和屏幕旋转中设置。</p><pre class=" language-javascript"><code class="language-javascript">document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span> </code></pre><p>那么如何把UE图中获取的像素单位转化为以rem为单位的值？公式是<code>（元素宽度/UE图宽度）*100</code>.假设UE图尺寸是640px,UE图中的一个元素宽度是100px,根据公式（100/640）*100=15.625。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生CSS画三角形</title>
      <link href="/2019/06/06/CSS%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2019/06/06/CSS%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p><strong>先将一个盒子的width和height都设置为0px，这一步是最关键的</strong></p><h3 id="画尖朝上的红色三角形"><a href="#画尖朝上的红色三角形" class="headerlink" title="画尖朝上的红色三角形"></a>画尖朝上的红色三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">}</span></code></pre><h3 id="画尖朝下的红色三角形"><a href="#画尖朝下的红色三角形" class="headerlink" title="画尖朝下的红色三角形"></a>画尖朝下的红色三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">}</span></code></pre><h3 id="画尖朝左的红色三角形"><a href="#画尖朝左的红色三角形" class="headerlink" title="画尖朝左的红色三角形"></a>画尖朝左的红色三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">}</span></code></pre><h3 id="画尖朝右的红色三角形"><a href="#画尖朝右的红色三角形" class="headerlink" title="画尖朝右的红色三角形"></a>画尖朝右的红色三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">}</span></code></pre><h3 id="画左上方的直角三角形"><a href="#画左上方的直角三角形" class="headerlink" title="画左上方的直角三角形"></a>画左上方的直角三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">}</span></code></pre><h3 id="画左下方的直角三角形"><a href="#画左下方的直角三角形" class="headerlink" title="画左下方的直角三角形"></a>画左下方的直角三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-right</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="画右上方直角三角形"><a href="#画右上方直角三角形" class="headerlink" title="画右上方直角三角形"></a>画右上方直角三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="画右下方直角三角形"><a href="#画右下方直角三角形" class="headerlink" title="画右下方直角三角形"></a>画右下方直角三角形</h3><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">border-top</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-left</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#fff</span><span class="token punctuation">;</span>    <span class="token property">border-bottom</span><span class="token punctuation">:</span><span class="token number">100</span>px solid <span class="token hexcode">#f00</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子模型</title>
      <link href="/2019/06/06/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/06/06/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h2><p>CSS盒子模型也叫框模型，具备内容(content),填充(padding),边框(border),边界(margin)这些属性，在CSS中，每一个元素都被视为一个盒子，且每一个盒子都有三个属性：</p><ol><li>border：元素的边框，用于将盒子的边缘与其他盒子分开。</li><li>margin：外边距，表示盒子的边缘与相邻盒子之间的距离，也称为页边空白。</li><li>padding：内边距，表示盒子内容和边框之间的空间。</li></ol><p>盒子的width和height指的是内容区域的宽度和高度，增加内边距，边框和外边距不会影响内容区域的尺寸，但是会增加盒子的总尺寸。</p><h2 id="盒子模型模式"><a href="#盒子模型模式" class="headerlink" title="盒子模型模式"></a>盒子模型模式</h2><h3 id="标准盒子模型：box-sizing-content-box"><a href="#标准盒子模型：box-sizing-content-box" class="headerlink" title="标准盒子模型：box-sizing:content-box"></a>标准盒子模型：box-sizing:content-box</h3><p>盒子总宽度=width+padding+border+margin</p><p>盒子的总高度=height+padding+border+margin</p><h3 id="IE盒子模型（怪异盒子模型）：box-sizing：border-box"><a href="#IE盒子模型（怪异盒子模型）：box-sizing：border-box" class="headerlink" title="IE盒子模型（怪异盒子模型）：box-sizing：border-box"></a>IE盒子模型（怪异盒子模型）：box-sizing：border-box</h3><p>盒子总宽度=width+margin；</p><p>盒子总高度=height+margin</p><p>用户自己设置的width=内容区域的宽度+border+padding</p><p>用户自己设置的height=内容区域的高度+border+padding</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圣杯布局和双飞翼布局</title>
      <link href="/2019/06/06/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
      <url>/2019/06/06/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局是一种常见的CSS布局，它要求：</p><ol><li>底部和顶部各自占领屏幕的全部宽度</li><li>上下部之间是一个三栏布局</li><li>三栏布局两侧宽度不变，中间部分自动填充整个区域</li><li>中间部分的高度是三栏中高度最高区域的高度</li></ol><p>下面介绍两种实现方式：</p><h3 id="浮动实现"><a href="#浮动实现" class="headerlink" title="浮动实现"></a>浮动实现</h3><pre><code>  &lt;style&gt;        .header,.footer{            height: 200px;            width: 100%;            background: #f40;        }        .footer{            clear:both;        }        .container{            padding-left:200px;&#x2F;&#x2F;这个就是左边盒子将来的宽度            padding-right:300px;&#x2F;&#x2F;这个就是右边盒子将来的宽度        }        .container div{            float: left;            position: relative;&#x2F;&#x2F;将所有的盒子设为相对定位        }        .mid{            width: 100%;            background: yellow;        }        .left{            width: 200px;            background: skyblue;            margin-left: -100%;&#x2F;&#x2F;很关键，margin-left：-100%是按照父盒子的宽度来计算的            left:-200px;&#x2F;&#x2F;很关键        }        .right{            width: 300px;            background: cyan;            margin-right:-300px;&#x2F;&#x2F;很关键        }&lt;&#x2F;style&gt;&lt;div class=&quot;header&quot;&gt;这里是头部&lt;&#x2F;div&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;mid&quot;&gt;中间部分&lt;&#x2F;div&gt;        &lt;div class=&quot;left&quot;&gt;左边&lt;&#x2F;div&gt;        &lt;div class=&quot;right&quot;&gt;右边&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;footer&quot;&gt;这里是底部&lt;&#x2F;div&gt;</code></pre><h3 id="flex弹性布局实现"><a href="#flex弹性布局实现" class="headerlink" title="flex弹性布局实现"></a>flex弹性布局实现</h3><p>弹性布局就是给外面的container盒子设置display：flex；然后左右固定宽度，中间的盒子设置flex：1即可。</p><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中</p><pre><code>&lt;style&gt;     .hd{            height:50px;            background: #666;            text-align: center;        }        .middle{            float:left;            width:100%;&#x2F;*左栏上去到第一行*&#x2F;            height:100px;            background:blue;        }        .left{            float:left;            width:180px;            height:100px;            margin-left:-100%;            background:#0c9;        }        .right{            float:left;            width:200px;            height:100px;            margin-left:-200px;            background:#0c9;        }        &#x2F;*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*&#x2F;        .inside{            margin:0 200px 0 180px;            height:100px;        }        .footer{            clear:both; &#x2F;*记得清楚浮动*&#x2F;            height:50px;            background: #666;            text-align: center;        }&lt;&#x2F;style&gt; &lt;div class=&quot;hd&quot;&gt;header&lt;&#x2F;div&gt;    &lt;div class=&quot;middle&quot;&gt;        &lt;div class=&quot;inside&quot;&gt;middle&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;left&quot;&gt;left&lt;&#x2F;div&gt;    &lt;div class=&quot;right&quot;&gt;right&lt;&#x2F;div&gt;    &lt;div class=&quot;footer&quot;&gt;footer&lt;&#x2F;div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中的百分比计算方法</title>
      <link href="/2019/06/06/css%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/06/06/css%E4%B8%AD%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>这一份笔记主要是来梳理一下css中涉及到的%计算。下面进入正题：</p><h2 id="css当中常用的属性百分比"><a href="#css当中常用的属性百分比" class="headerlink" title="css当中常用的属性百分比"></a>css当中常用的属性百分比</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">解析</th></tr></thead><tbody><tr><td style="text-align:center">width</td><td style="text-align:center">基于父元素的width</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">基于父元素的height</td></tr><tr><td style="text-align:center">margin(top,bottom,left,right)</td><td style="text-align:center">基于父元素的width</td></tr><tr><td style="text-align:center">padding(top,bottom,left,right)</td><td style="text-align:center">基于父元素的width</td></tr><tr><td style="text-align:center">left,bottom,right,top</td><td style="text-align:center">left/right基于父元素的width，top/bottom基于父元素的height</td></tr><tr><td style="text-align:center">font-size</td><td style="text-align:center">基于继承得到的font-size</td></tr><tr><td style="text-align:center">line-height</td><td style="text-align:center">基于自身的font-size</td></tr><tr><td style="text-align:center">translate(x,y)</td><td style="text-align:center">基于自身的width和height</td></tr></tbody></table><p><strong>注意</strong>：</p><p>给子元素设置<code>height:50%;</code>,会基于父元素的height来计算，但是这种情况必须是父元素显示的在css上面写上height等于多少，如果没有写，那么父元素div1的高度就是自动撑开的，那么子元素里的<code>height:50%</code>将不会有任何效果。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子居中方法</title>
      <link href="/2019/06/06/%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD/"/>
      <url>/2019/06/06/%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子没有固定的宽和高"><a href="#盒子没有固定的宽和高" class="headerlink" title="盒子没有固定的宽和高"></a>盒子没有固定的宽和高</h2><h2 id="利用transform"><a href="#利用transform" class="headerlink" title="利用transform"></a>利用transform</h2><p>在需要居中对齐的块中首先采用绝对定位，其父盒子采用相对定位。然后<code>transform:translate(-50%,-50%);left:50%;top:50%</code></p><h2 id="采用flex布局"><a href="#采用flex布局" class="headerlink" title="采用flex布局"></a>采用flex布局</h2><p>父盒子采用flex布局。给父盒子加上<code>display:flex;justify-content:center;align-items:center</code></p><h2 id="盒子有固定的宽和高"><a href="#盒子有固定的宽和高" class="headerlink" title="盒子有固定的宽和高"></a>盒子有固定的宽和高</h2><h3 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h3><p>给需要居中的盒子加上<code>left:50%;top:50%; margin-left:-自身宽度的一半；margin-top:-自身高度的一半</code></p><h3 id="非常规的做法"><a href="#非常规的做法" class="headerlink" title="非常规的做法"></a>非常规的做法</h3><p>将需要居中的盒子绝对定位，其父盒子采用相对定位。然后<code>left:0;top:0;top:0;bottom:0;margin:auto;</code></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短连接/长短轮询</title>
      <link href="/2019/06/05/%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/06/05/%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p>定义：就是普通的轮询，指在特定的时间间隔，由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。短轮询是服务器立即发送响应，无论数据是否有效。</p><p>应用场景：传统的web通信，后台处理数据需要一定的时间，前端想要知道后端的处理结果，就要不定时向后端发出请求以获得最新情况。</p><p>缺点：请求中有一大半是无用，浪费带宽和服务器资源。而且实时性不高。适合用在对实时性要求不高的地方。</p><p><img src="/2019/06/05/长短连接/短轮询.PNG" alt></p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>定义：服务器收到请求之后如果有数据，就立刻响应请求，如果没有数据就将请求挂起一段时间，在这个时间里如果有数据就立即响应请求并关闭连接，没有数据就等到连接超时为止。客户端处理完响应信息后再向服务器发送新的请求。</p><p>优点：客户端请求次数将大大减小，节省了网络流量。</p><p>缺点：服务器挂起请求会消耗资源，</p><p>应用场景：长轮询一般用在实时性要求高的场景，因为http长轮询的控制权一直是在服务器端，而数据是在服务器端的，因此实时性高。</p><p><img src="/2019/06/05/长短连接/长轮询.PNG" alt></p><h1 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h1><p>HTTP分为长连接和短连接，其本质上是TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接一说，HTTP协议是应用层的协议，而TCP协议才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>HTTP1.0规定浏览器与服务器只能保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。</p><p>缺点：使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里面包含的其他资源，因此，每一次请求都会造成无谓的TCP连接建立和断开，增加通信开销。</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>为了解决上述TCP连接的问题，HTTP/1.1提出了持久连接的方法，持久连接的特点是<strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></p><p>在HTTP/1.1中，所有的连接都默认是持节连接，可以通过<code>Connection:keep-alive</code></p><p>优点：减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负担。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="/2019/06/05/TCP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/05/TCP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP报文的若干首部关键字段"><a href="#TCP报文的若干首部关键字段" class="headerlink" title="TCP报文的若干首部关键字段"></a>TCP报文的若干首部关键字段</h2><p><strong>确认ACK</strong>:仅当ACK=1时确认号字段才有效，当ACK=0时，确认号无效。<strong>TCP规定，在连接建立之后所有传送的报文字段都必须要把ACK置为1</strong></p><p><strong>同步SYN</strong>：在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文段，对方如果同意建立连接，则应该在响应的报文段使得SYN=1且ACK=1,因此，SYN=1就表明这是一个连接请求或者连接接受报文。</p><p><strong>终止FIN</strong>：用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</p><p><strong>序号</strong>：在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号，整个要传送的字节流的起始序号必须要连接建立时设置。在连接建立时的序号用seq表示。</p><p><strong>确认号</strong>：是期望收到对方下一个报文段的第一个数据字节的序号。在建立阶段用ack表示。</p><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><p><img src="/2019/06/05/TCP协议/三次握手.PNG" alt></p><ol><li>A在打算建立TCP连接时，向B发出一个连接请求报文，这时，首部中的同步为SYN =1,同时选择一个初始序号seq = x。</li><li>B在收到A的连接请求报文后，如果同意建立连接，就在确认报文中把SYN = 1,ACK = 1。同时，设置确认号ack = x+1,同时设置自己的初始序号seq = y。</li><li>A在收到B的确认之后，还要向B给出确认，确认报文的ACK置1，确认号ack为y+1,而自己的序号seq此时为x+1；</li></ol><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q</strong>:为什么A最后还要向B发送一次确认呢？</p><p><strong>A</strong>:主要是<strong>为了防止已经失效了的连接请求报文突然又传到了B而产生错误</strong>。所谓已经失效了的连接请求报文是这样产生的，考虑一种正常情况:A发出连接请求，但是因为连接请求丢失而问收到确认。于是，A再重传一次连接请求，后来收到来确认，建立了连接，数据传输完毕之后，就释放了连接，A一共发出了两个连接请求报文段，其中一个丢失，一个到达了B.没有已失效的连接请求报文段。</p><p>现在假定出现了一种异常情况，即A发出的第一个连接请求报文并没有丢失，而是在某些网络节点长时间滞留了，以致于这个连接请求到了后来的某个时间才达到B.本来这是一个早就失效的报文段，但是B收到此失效的连接请求报文段之后，就误以为是A又发出了一次新的连接请求，于是就向A发出确认报文，同意建立连接，假定不采用报文握手，只要B发出确认，新的连接就建立了。</p><p>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据，但是B却以为新的连接已经建立，并一直等待A的数据，B的许多资源就这样被白白浪费了。</p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="/2019/06/05/TCP协议/四次挥手.PNG" alt></p><ol><li>A主动关闭TCP连接，A把连接释放报文首段的终止控制位FIN = 1;其序号seq = u，它等于前面已经传送过的数据的最后一个字节的序号加1.</li><li>B收到连接释放报文后立即发出确认，确认号ack = u+1，而这个报文段自己的序号是v，等于B前面已经传送过的数据的最后一个字节序号加1.此时只是A到B的连接中断了。</li><li>如果B也没有要向A发送的数据了，就发出连接释放报文，假定此时B的序号是w（在半关闭的状态下B又发送了一些数据）B还必须重复自己已经发送过的确认号ack=u+1;</li><li>A在收到B的连接释放报文段后，必须对此发出确认，在确认报文段中把ACK=1,确认号ack = w+1;而自己的序号seq = u+1;(根据TCP协议规定，A第一次发送FIN报文要消耗一个序号)</li></ol><h3 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q</strong>:为什么要四次挥手</p><p><strong>A</strong>:由于TCP是一个全双工的连接，这意味着连接的两端既可以发送数据，也可以接受数据。前两步只是表明A没有要发送给B的数据了，断开的只是A到B的发送数据的通过，并不影响A接受B的数据，前两步之后，如果B还有需要向A发送的数据，依然可以正常的发送给A，A也可以正常的接收到，只有当B也断开了给A发送数据的通道时，这个TCP连接才算真正的断开。所以综上所述，断开一个TCP连接需要四步。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用<strong>滑动窗口机制</strong>可以很方便的在TCP连接上实现对发送方的流量控制。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP进行拥塞控制的算法由四种：</p><ol><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><p>慢开始算法的思路是当主机开始发送数据额时候，由于并不清楚网络的负荷情况，所以，由小到大逐渐增大拥塞窗口数值。使用慢开始算法之后，每经过一个传输轮次，拥塞窗口就加倍。为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限，慢开始门限使用方法如下：</p><p>当拥塞窗口&lt;慢开始门限：使用慢开始算法</p><p>当拥塞窗口&gt;慢开始门限：使用拥塞避免算法</p><p>当拥塞窗口=慢开始门限：使用拥塞避免算法或者慢开始算法</p><p>拥塞避免算法的思路是让拥塞窗口缓慢增大，即每经过一个传输轮次把发送方的拥塞窗口加1，而不是像慢开始阶段那样加倍增长，因此在拥塞避免阶段就有加法增大的特点。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失，快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段后也要立即发出对已收到报文的重复确认，快重传算法规定，发送方一旦收到连续三个重复确认，就确认接收方存在报文丢失，就要立即进行重传。</p><p>在知道只是丢失了个别的报文段之后，并不启动慢开始，而是启动快速恢复。发送方调整门限为当前拥塞窗口的一半，并将拥塞窗口也减半，然后开始执行拥塞避免算法。</p><p>在拥塞避免阶段，拥塞窗口是按照线性规律增大的，称为加法增大，而一旦出现超时或者3个重复的确认，就要把门限值设置为当前拥塞窗口的一半，并大大减少拥塞窗口的数值，称为乘法减少。</p><h2 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h2><p>拥塞控制是为了防止过多的数据注入到网络，这样可以使得网络中的路由器或者环路不至于过载，是一个全局性的过程，涉及到所有的主机，所有的路由器，以及所有与降低网络传输性能相关的所有因素。</p><p>流量控制往往是点对点通信量的控制，是个端到端的问题（接收端控制发送端）流量控制所要做的就是抑制发送端发送数据的速率，以便使得接收端来得及接收。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组常用方法</title>
      <link href="/2019/05/31/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/31/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-isArray-对象"><a href="#Array-isArray-对象" class="headerlink" title="Array.isArray(对象)"></a>Array.isArray(对象)</h3><p>判断这个对象是不是一个数组</p><h3 id="concat-数组"><a href="#concat-数组" class="headerlink" title=".concat(数组)"></a>.concat(数组)</h3><p>返回一个拼接的新数组</p><h3 id="push-值"><a href="#push-值" class="headerlink" title=".push(值)"></a>.push(值)</h3><p>在原数组的最后面添加上这个值，返回值是新数组的长度</p><h3 id="unshift-值"><a href="#unshift-值" class="headerlink" title=".unshift(值)"></a>.unshift(值)</h3><p>在原数组的最前面添加上这个值，返回值是新数组的长度</p><h3 id="pop"><a href="#pop" class="headerlink" title=".pop"></a>.pop</h3><p>将原数组最后一个值弹出，返回值是弹出的这个值</p><h3 id="shift"><a href="#shift" class="headerlink" title=".shift"></a>.shift</h3><p>将原数组第一个值弹出，返回值是弹出的这个值。</p><h3 id="reverse"><a href="#reverse" class="headerlink" title=".reverse"></a>.reverse</h3><p>将原数组逆序，返回值是经过排序之后的数组（是数组本身）</p><h3 id="sort"><a href="#sort" class="headerlink" title=".sort"></a>.sort</h3><p>将原来数组按一定顺序排列，不稳定，可以在这个方法中传入一个比较函数。返回值是经过排序之后的数组。</p><h3 id="slice-开始的索引，结束的索引"><a href="#slice-开始的索引，结束的索引" class="headerlink" title=".slice(开始的索引，结束的索引)"></a>.slice(开始的索引，结束的索引)</h3><p>将原来数组从开始的索引到结束的索引的中间那一段数组内容截取出来，放在新数组中，这个操作本身不影响原来的数组。</p><h3 id="splice"><a href="#splice" class="headerlink" title=".splice"></a>.splice</h3><p>splice方法传入的参数个数取决于使用这方法所要达到的效果，具体而言，就是：</p><ol><li>删除：传入两个参数，起始位置，删除的个数</li><li>插入：传入三个参数，插入位置，0（表示不删除任何元素），要插入的元素</li><li>替换：传入三个参数，替换位置，要替换的元素的个数，要替换的元素</li></ol><p><strong>注意</strong>：</p><p>splice方法对于数组的操作会影响原来数组</p><h3 id="find"><a href="#find" class="headerlink" title=".find"></a>.find</h3><p>接收一个方法作为参数，方法内部会返回一个条件，find会遍历数组的所有元素，符合这个条件的元素会被返回，如果遍历完整个数组都没有符合条件的元素，会返回undefined</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> arr <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">return</span> item <span class="token operator">==</span><span class="token number">20</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    这个函数会返回数组中值是<span class="token number">20</span>数</code></pre><h3 id="findIndex"><a href="#findIndex" class="headerlink" title=".findIndex"></a>.findIndex</h3><p>作用和find方法类似，但是不同的是，这个方法返回的是数组中符合条件的元素在数组中的索引。</p><h3 id="join-拼接符"><a href="#join-拼接符" class="headerlink" title=".join(拼接符)"></a>.join(拼接符)</h3><p>返回一个将数组中所有元素使用拼接符拼接起来的字符串</p><h3 id="every，filter，forEach，map，some"><a href="#every，filter，forEach，map，some" class="headerlink" title="every，filter，forEach，map，some"></a>every，filter，forEach，map，some</h3><p>这几个方法都会遍历整个数组，但是，就其作用而言，却不尽相同，具体而言：</p><ol><li>every：接收一个函数作为参数，这个函数的第一个参数是元素的值，第二个参数是元素的索引，every会遍历整个数组，只有当数组中的每一个元素都满足参数函数的条件时，才会返回true</li><li>some：作用和every相似，但不需要数组中每一个元素都满足条件，只要存在一个元素满足这个条件就返回true。</li><li>filter：根据传入的参数函数对数组中每一个元素进行过滤判断，返回的值是所有满足条件的元素组成的新数组</li><li>forEach：对数组中每一个元素遍历执行参数函数中的操作。没有返回值</li><li>map:数组中每一个元素都要执行这个函数，并将执行后的结果放在一个新数组中返回。</li></ol><p><strong>上述所有遍历数组的方法均不会改变原来数组中元素的值。</strong></p><p><strong>tips:</strong>如何中断一个forEach循环<br>forEach一般是无法通过return或者是break进行中断的，在这里，介绍一个通过try/catch的方法进行中断。具体代码示例如下：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//我们的目的是使用forEach遍历数组，在遇到2的时候中断。</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'遇到2了，可以中断吗？'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                foreach<span class="token punctuation">.</span><span class="token keyword">break</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Stop'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message <span class="token operator">===</span> <span class="token string">'foreach is not defined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'中断成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>注意</strong>：遇到这种情况，也可以考虑使用数组的some方法或者是every方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器对象模型(BOM)</title>
      <link href="/2019/05/30/BOM/"/>
      <url>/2019/05/30/BOM/</url>
      
        <content type="html"><![CDATA[<p>BOM提供了很多对象，用于访问浏览器的功能。</p><h2 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h2><p>IE,Safari,Opera和Chrome使用<strong>screenLeft</strong>和<strong>screenTop</strong>分别用来表示浏览器窗口相对电脑屏幕的左边和上边的距离。而在FireFox中。使用的是<strong>screenX</strong>和<strong>screenY</strong>来表示相同的值。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>screenLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>screenTop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//火狐浏览器这样使用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>screenX<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>screenY<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="/2019/05/30/BOM/screen.png" alt></p><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>在IE9+,Safari,Opera和chrome中，<code>outerWidth</code>和<code>outerHeight</code>返回浏览器本生的大小，而innerWidth和innerHeight返回该容器中视图区域的大小(减去浏览器工具栏边框剩下的展示内容的区域)</p><p>在IE,Safari,Opera,Chrome,FireFox中。<code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>保存了页面视口信息。</p><p><strong>ps</strong>:视口就是指浏览器展示内容的区域，不包括浏览器上面工具栏。</p><p><img src="/2019/05/30/BOM/窗口大小.png" alt></p><h2 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h2><ol><li><p>hash：返回URL中#后面的内容，没有则返回一个空字符串。</p></li><li><p>host：返回服务器名称和端口号</p></li><li><p>hostname：返回不带端口号的服务器名称</p></li><li><p>href：返回当前加载页面完整的URL</p></li><li><p>pathname：返回URL中的目录和文件名</p></li><li><p>port：返回URL中的端口号</p></li><li><p>protocol：返回页面使用的协议，一般时http或者https</p></li><li><p>search:返回URL中包含的查询字符串，这个字符串以？开头。</p><p><img src="/2019/05/30/BOM/location对象.PNG" alt></p></li></ol><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><ol><li>assign(url):调用location.assign(url)方法。可以立即打开信的URL并在浏览器历史记录里新生成一条记录。可以回退到前一个url地址。</li><li>replace(url):调用location.replace(url)方法，可以替换到传入信的url地址，但是浏览器历史记录中不会有这条记录，无法通过浏览器后退到前一个url。</li><li>reload():重新加载当前的显示页面。如果传入参数true，则强制从服务器重新加载。</li></ol><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><pre class=" language-javascript"><code class="language-javascript">history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后退一页</span>history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前进一页</span>history<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前进</span>history<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后退。</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载和图片预加载</title>
      <link href="/2019/05/30/%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/05/30/%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>懒加载</strong>也叫延迟加载，即延迟加载图片或者符合某种条件时才加载某些图片。牺牲了服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的响应。</p><p><strong>预加载</strong>是提前加载图片，当用户需要查看时可以直接从本地缓存中渲染。作为服务器前端的优化，减少请求次数或者延迟请求。</p><p><strong>本质</strong>：两者的行为是相反的，一个是提前加载，一个是迟缓加载甚至是不加载，懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端的压力。</p><h2 id="懒加载实现"><a href="#懒加载实现" class="headerlink" title="懒加载实现"></a>懒加载实现</h2><p>实现方式:可视区加载。即仅加载用户可以看到的区域，这个主要是由监控滚动条来实现，一般会在距离用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。</p><p><strong>Tips</strong></p><ol><li>自定义属性，以<code>data-</code>为前缀，可以通过绑定的DOM对象的dataset来获取自定义属性的值。</li><li>DOM API <code>getBoundingClientRect</code>：这个API会返回一个对象，蓝色区域表示DOM实际所在的地方，top属性表示元素顶端距离视口顶端的位置。</li></ol><p><img src="/2019/05/30/懒加载和预加载/getBoundingClientRect.png" alt></p><ol start="3"><li>不能直接给<code>img</code>标签设置<code>src</code>属性</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">'container'</span><span class="token operator">></span>    <span class="token operator">&lt;</span>img src <span class="token operator">=</span> <span class="token string">''</span> alt<span class="token operator">=</span><span class="token string">'lazy-load'</span> data<span class="token operator">-</span>src <span class="token operator">=</span> <span class="token string">'图片实际的url地址'</span><span class="token operator">></span>        <span class="token operator">...</span> <span class="token comment" spellcheck="true">//此处略去多个相同的img标签。</span>   <span class="token operator">&lt;</span>img src <span class="token operator">=</span> <span class="token string">''</span> alt<span class="token operator">=</span><span class="token string">'lazy-load'</span> data<span class="token operator">-</span>src <span class="token operator">=</span> <span class="token string">'图片实际的url地址'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span>script<span class="token operator">></span>       <span class="token comment" spellcheck="true">//所有具有data-src属性的图片都需要懒加载。</span>       <span class="token keyword">function</span> <span class="token function">lazyLoad</span><span class="token punctuation">(</span>defaultImg<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//第0步，先得到所有需要懒加载的图片</span>               <span class="token keyword">var</span> imgs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'img[data-src]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//将其转化为真正的数组</span>               imgs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>imgs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//设置默认图片</span>               <span class="token function">setDefaultImgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//懒加载所有图片</span>               <span class="token function">loadAllImgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//监听滚动条</span>               <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>               document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//函数防抖</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">clearTimeOut</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>                 timer <span class="token operator">=</span> <span class="token function">setTimeOut</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">loadAllImgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>               <span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>函数区<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>           <span class="token function">setDefaultImgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>defaultImg<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token punctuation">;</span>               <span class="token punctuation">}</span>               imgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token operator">></span>item<span class="token punctuation">.</span>src <span class="token operator">=</span>defaultImg <span class="token punctuation">)</span>           <span class="token punctuation">}</span>           <span class="token keyword">function</span> <span class="token function">loadAllImgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               imgs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">loadImg</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                       imgs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       index<span class="token operator">--</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span><span class="token punctuation">)</span>           <span class="token punctuation">}</span>               <span class="token comment" spellcheck="true">/*               *懒加载一张图片，自行判断是否应该加载               *img：图片的dom对象               */</span>           <span class="token keyword">function</span> <span class="token function">loadImg</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//判断该图片是否能够加载。实际上时判断该图片是否在可视区范围内</span>               <span class="token keyword">var</span> rect <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>rect<span class="token punctuation">.</span>bottom<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>rect<span class="token punctuation">.</span>top<span class="token operator">>=</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span>               <span class="token punctuation">}</span>               img<span class="token punctuation">.</span>src <span class="token operator">=</span> img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//判断是否由原图</span>               <span class="token keyword">if</span>（img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>original）<span class="token punctuation">{</span>                   img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                       img<span class="token punctuation">.</span>src <span class="token operator">=</span> img<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>original<span class="token punctuation">;</span>                       img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不写这一步就会导致无限循环。因为小图加载完触发onlod时间后，大图加载完又触发onload事件。</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span>               <span class="token keyword">return</span> <span class="token boolean">true</span>           <span class="token punctuation">}</span>           <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>       </code></pre><h2 id="预加载实现"><a href="#预加载实现" class="headerlink" title="预加载实现"></a>预加载实现</h2><p>​    核心原理是浏览器请求过的资源会有缓存，所以使用js创建一个看不见的img标签，浏览器就会发出请求，这个过程用户是看不见的，到了页面上真正要显示这张图片的时候，浏览器一检查之前缓存过，就不会再向服务器发出请求，直接从缓存中获取，给用户的感觉就是秒加载了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">preloadImg</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>complete<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果有缓存</span>        <span class="token comment" spellcheck="true">//接下来可以使用图片了</span>        <span class="token comment" spellcheck="true">//do something here</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//接下来可以使用图片了</span>            <span class="token comment" spellcheck="true">//do something here</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/05/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/05/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>处理字符串的利器.主要作用是判断字符串中是否含有符合正则表达式匹配规则的片段</p></blockquote><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>方法1：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/abc/</span></code></pre><p>方法2：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span></code></pre><h2 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h2><p><strong>g:全局匹配</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg1 <span class="token operator">=</span> <span class="token regex">/a/</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg2 <span class="token operator">=</span> <span class="token regex">/a/g</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abcda'</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是一个数组['a']</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是一个数组['a','a']</span><span class="token comment" spellcheck="true">//所谓全局匹配就是会匹配整个字符串中所有符合规则的片段,而不只是简简单单的找到第一个符合的字符串片段就结束匹配.</span></code></pre><p><strong>i:忽略大小写</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> rge1 <span class="token operator">=</span> <span class="token regex">/abc/</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg2 <span class="token operator">=</span> <span class="token regex">/abc/i</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token regex">/aBcd/</span><span class="token punctuation">;</span>reg1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果为false</span>reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果为true</span><span class="token comment" spellcheck="true">//所谓忽略大小写就是指匹配规则不受字符大小写影响.</span></code></pre><p><strong>m:多行匹配</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg1 <span class="token operator">=</span> <span class="token regex">/^a/g</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg2 <span class="token operator">=</span> <span class="token regex">/^a/gm</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abcd\na'</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是一个数组['a']</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是一个数组['a','a']</span></code></pre><h2 id><a href="#" class="headerlink" title="[]"></a>[]</h2><p>一个[]表示一位,[]里面的内容是规定这一位可以取值的范围.例如<code>[1-9]</code>表示这一位的取值范围是1-9数字.</p><p><strong>注意:</strong><code>^</code>写在[]表示非的意思,写在[]表示以这个字符开头</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg1 <span class="token operator">=</span> <span class="token regex">/[0-9]/g</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'ab1cd2'</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是['1','2'];</span><span class="token keyword">var</span> reg2 <span class="token operator">=</span> <span class="token regex">/[^abc]/g</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">'abcd'</span><span class="token punctuation">;</span>str2<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是['d']</span></code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="()"></a>()</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(abc|bcd)/g</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">'ab'</span><span class="token punctuation">;</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果为true</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果为false</span></code></pre><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>拥有特殊含义的字符.<strong>一个元字符也只代表一位</strong></p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除了换行符之外的所有字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配数字,字母,下划线</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配不是数字,字母以及下划线</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配一个数字</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配一个非数字的字符</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空白字符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任何一个非空白字符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词边界</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配非单词边界</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配开头</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配结尾</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配连续出现0次到多次的字符</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配连续出现0次到一次的字符</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配连续出现一次到多次的字符</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">匹配连续出现n次的字符</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">匹配至少连续出现n次的字符</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配至少连续出现n次,最多不超过m次的字符</td></tr></tbody></table><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abc bcd cde'</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/\bb/</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回的是['b']而且这个b是bcd里面的那个b</span></code></pre><h3 id="exec方法"><a href="#exec方法" class="headerlink" title="exec方法"></a>exec方法</h3><p>每一个正则表达式对象都有exec这个方法,它的用法如下:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'ababab'</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/ab/g</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>正则表达式是全局匹配的模式下<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:2,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:4,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是null</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>正则表达式不是全局匹配的模式下<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span>res<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果是一个类数组['ab',index:0,input:'ababab']</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>这里的index就对应着reg<span class="token punctuation">.</span>lastIndex这个属性<span class="token punctuation">.</span></code></pre><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>反向引用需要使用到分组，分组就是使用()括起来的部分为一个整体，在进行分组匹配时的原则是：由外向内，由左向右.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'aabb'</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1(\w)\2/g</span><span class="token comment" spellcheck="true">// \1：表示的是引用第一次匹配到的()括起来的部分</span><span class="token comment" spellcheck="true">// \2：表示的是引用第二次匹配到的()括起来的部分</span></code></pre><pre class=" language-javascript"><code class="language-javascript">题目<span class="token punctuation">:</span>将<span class="token string">'the-first-name'</span>转换为<span class="token string">'theFirstName'</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'the-first-name'</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/-(\w)/g</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token punctuation">(</span>$<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>$<span class="token number">1</span><span class="token punctuation">.</span>toUpperCase<span class="token punctuation">)</span>replace方法中的回调函数的第一个参数是正则表达式匹配到的字符串片段<span class="token punctuation">,</span><span class="token function">$1是正则表达式第第一次匹配到的</span><span class="token punctuation">(</span><span class="token punctuation">)</span>括起来的部分<span class="token punctuation">,</span>依次可以有$<span class="token number">2</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token operator">...</span><span class="token punctuation">.</span></code></pre><h2 id="正向预查"><a href="#正向预查" class="headerlink" title="正向预查"></a>正向预查</h2><pre class=" language-JavaScript"><code class="language-JavaScript">var str = 'abaaaa'//需求是匹配后面紧跟着的字符是'b'的avar reg = /a(?=b)/g;//查找后面紧跟的是b的a，括号后面的东西只是为了修饰前面要匹配的主体//需求是匹配后面紧跟着的字符不是'b'的avar reg2 = /a(?!b)/g//查找后面不是b的a</code></pre><h2 id="贪婪匹配和非贪婪匹配"><a href="#贪婪匹配和非贪婪匹配" class="headerlink" title="贪婪匹配和非贪婪匹配"></a>贪婪匹配和非贪婪匹配</h2><p>默认情况是贪婪匹配,要改成非贪婪匹配,在量词后面加一个?</p><pre class=" language-JavaScript"><code class="language-JavaScript">var str = 'aaaaa';var reg = /a{1,3}/gstr,match(rge);//结果是['aaa','aa']var reg2 = /a{1,3}?/gstr.match(reg2);//结果是['a','a','a','a','a']</code></pre><h3 id="一个有趣的demo"><a href="#一个有趣的demo" class="headerlink" title="一个有趣的demo"></a>一个有趣的demo</h3><pre class=" language-javascript"><code class="language-javascript">需求<span class="token punctuation">:</span>给定一个数字<span class="token number">100000000</span><span class="token punctuation">,</span>要求将其转换为<span class="token number">100</span><span class="token punctuation">,</span><span class="token number">000</span><span class="token punctuation">,</span><span class="token number">000</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'100000000'</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(?=(\B)(\d{3})+$)/g</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex学习笔记</title>
      <link href="/2019/05/23/vuex%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/05/23/vuex%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><blockquote><p>vuex是专门为vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可以预测的方式发生变化。</p><p>​                                                                    ———–引自vuex官网</p></blockquote><p><strong>我的理解</strong>：vuex是为了保存组件之间共享数据而诞生的，如果组件之间有需要共享的数据，可以直接挂载到vuex中，而不必通过组件之间父子传值。<strong>vuex就是一个全局共享数据存储区域，相当于是一个数据的仓库</strong></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一般情况下使用vue-cli创建的项目的vuex是定义在项目src目录下的<code>store.js</code>的文件里的，下面是一个典型的<code>store.js</code>文件的结构:</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span> <span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span> <span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span><span class="token punctuation">{</span>        count<span class="token punctuation">:</span><span class="token number">0</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//全局共享数据存放区，以count为例</span>    mutaitions：<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//mutations里面定义的方法的第一个参数默认是state。第二个参数可以是从外界调取该方法传入的参数    </span>        <span class="token function">add</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>            state<span class="token punctuation">.</span>count <span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//更改 Vuex 的 store 中的状态的方法区</span>    actions<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义在actions里面的方法都默认接受一个context参数，这个context是一个和store实例具有相同属性和方法的对象</span>        <span class="token keyword">async</span> <span class="token function">myadd</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在这些函数里面就这样调用mutations里面的方法</span>            <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`当前count是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>context<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">>>>>>>></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//类似于mutation，但是可以有一些异步操作方法在里面。配合async/await食用更佳</span>    getters：<span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//getters属性存储的方法默认接受一个参数为state，这些方法只能只读性的去访问state里面的属性，每一个定义在getters方法一般都会return一个东西</span>        <span class="token function">getCount</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`count:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对state中存放的变量的只读性操作的方法存放区</span>    modules：<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>这个属性里存放着组件间需要共享的数据，如果在某个组中想要访问state里面的<code>count</code>，只能通过<code>this.$store.state.count</code>来访问。</p><p>在实际操作中，可以使用mapState来简化访问操作，具体而言就是在组件的computed属性中使用mapState</p><pre class=" language-JavaScript"><code class="language-JavaScript">    import {mapState} from 'vuex'    export default {        computed:{            ...mapState(['count'])//数组中的元素就是你在这个组件中想要访问的state上的数据的名字        }    }//通过这样的操作，再在组件中访问这个属性的时候，原来的方法是{{ $store.state.count}},现在是{{count}}</code></pre><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>如果想要改变state里面存储的变量的状态，只能使用在mutations定义的方法来操作对应的属性,不推荐直接操作state里面的数据，因为万一导致了数据的紊乱，不能快速定位到错误的原因，因为每个组件中都可能有操作数据的方法。</p><p>如果在组件中想调用定义在mutations里面的方法，原始的途径是通过<code>this.$store.commit(&#39;add&#39;,args)</code>。在实际操作中，可以使用mapMutations来简化操作,具体而言就是在组件methods方法中使用mapMutations</p><pre class=" language-JavaScript"><code class="language-JavaScript">    import {mapMutations} from 'vuex'    export default {        methods:{            myAdd(){                this.add(args)//this.$store.commit('add',agrs)            }            ...mapMutations(['add'])        }    }</code></pre><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>这个属性中的方法类似于计算属性，当state里面的相关数据改变的时候，就会调用这个方法。在实际操作中使用mapGetters来方便我们操作，具体而言就是在组件的computed属性中使用mapGetters</p><pre class=" language-JavaScript"><code class="language-JavaScript">    import {mapGetters} from 'vuex'    export default {        computed:{            ...mapGetters(['getCount'])//        }    }   原始的使用方式是{{$store.getters.getCount}},在使用完mapGetters之后在组件中就可以通过{{getCount}}来调用这个方法。当state里面的count属性值变化的时候，就会调用getCount方法，从而更新视图。</code></pre><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>Action 类似于 mutation，不同在于：</p><ol><li>Action 提交的是 mutation，而不是直接变更状态</li><li>Action 可以包含任意异步操作。</li></ol><p>在组件间使用的actions里面的方法时，最原始的方法是通过<code>this.$store.dispatch()</code>,通过使用mapActions可以简化这个操作,具体而言，就是在组件的methods属性中使用mapActions</p><pre class=" language-JavaScript"><code class="language-JavaScript">    import {mapActions} from 'vuex'    export default {        methods:{            async myAdd(){                var result = await this.myadd()//this.$store.dispatch('myadd')                console.log(result)            }            ...mapActions(['myadd'])        }    }</code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>这个属性只是为了对存储在state里面的数据做模块性分隔，假设此时我们有两个store对象，一个是app，一个是user，里面的内容分别是</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span><span class="token punctuation">{</span>        count<span class="token punctuation">:</span><span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mutations<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>            state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    getters<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">dec</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`current count is{state.count}`</span></span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    actions<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> app</code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span><span class="token punctuation">{</span>        userInfo<span class="token punctuation">:</span><span class="token keyword">null</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> user</code></pre><p>而在store.js里面就是</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> app <span class="token keyword">from</span> <span class="token string">'app.js'</span><span class="token keyword">import</span> user <span class="token keyword">from</span> <span class="token string">'user.js'</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span><span class="token punctuation">{</span>        app<span class="token punctuation">,</span>user    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这样就完成了状态的模块划分。这样之后，需要在组件中稍加修改</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>mapState<span class="token punctuation">,</span>mapMutations<span class="token punctuation">,</span>mapGetters<span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    computed<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>            <span class="token function">count</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> state<span class="token punctuation">.</span>app<span class="token punctuation">.</span>count<span class="token comment" spellcheck="true">//原来没模块划分的时直接是...mapState(['count]),划分之后要做一层映射，这样就可以以{{count}}的形式来访问app里的state里面state存储的count属性了</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios学习笔记</title>
      <link href="/2019/05/23/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/23/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>axios：一个基于promise的ajax类库</p><p>引入axios.js这个文件之后，向外暴露了一个对象axios</p><h2 id="发送get请求"><a href="#发送get请求" class="headerlink" title="发送get请求"></a>发送get请求</h2><pre class=" language-javascript"><code class="language-javascript">axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token punctuation">{</span>params：<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>mse<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第二个参数是option配置对象。params就是请求传递的参数，发送请求的配置参数也写在这里</span><span class="token comment" spellcheck="true">//请求成功就进入then里面的函数，返回的结果是一个对象res，服务器返回的数据都在res.body里面存着。如果在发起请求的时候传入了参数，那么传入的参数在res.config.params里面。</span><span class="token comment" spellcheck="true">//请求失败就进入catch，返回结果msg是请求失败的原因。</span></code></pre><h2 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h2><pre class=" language-javascript"><code class="language-javascript">axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span>，<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//第二个参数就是post请求要传递的参数，第三个参数是配置参数</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">//请求成功就进入then里面的函数，返回的结果是一个对象res，服务器返回的数据都在res.body里面存着。如果在发起请求的时候传入了参数，那么传入的参数在res.config.data里面。</span><span class="token keyword">catch</span><span class="token punctuation">(</span>mse<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//请求失败就进入catch，返回结果msg是请求失败的原因。</span></code></pre><h2 id="axios-all"><a href="#axios-all" class="headerlink" title="axios.all"></a>axios.all</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getUserAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getUserPromission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>axios<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>getUserAccount<span class="token punctuation">,</span>getUserPromission<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里只有当前面数组中的两个请求都成功后才会进入后面的then，这里的res是一个数组，里面的值一次是这两个请求的返回结果。</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//或者这样使用</span>axios<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>getUserAccount（）<span class="token punctuation">,</span>getUserPromission（）<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>axios<span class="token punctuation">.</span><span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>acct<span class="token punctuation">,</span> perms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//acct是第一个请求的返回结果，perms是第二个请求的返回结果</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在请求或者相应被<code>then</code>或者<code>catch</code>处理之前拦截他们.在成功之前先执行拦截器的success方法，将成功的方法的返回值传给自己定义的请求成功的方法去处理。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//请求拦截器</span>axios<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//在发送请求之前做什么</span>    <span class="token keyword">return</span> config<span class="token punctuation">}</span>，<span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对请求错误做什么</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//相应拦截器</span>axios<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对成功的响应做些什么</span>    <span class="token keyword">return</span> success<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对失败的响应做些什么</span>    retur Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//移除拦截器</span><span class="token keyword">const</span> myInterceptor <span class="token operator">=</span> axios<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>axios<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">eject</span><span class="token punctuation">(</span>myInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="在VUE下使用axios"><a href="#在VUE下使用axios" class="headerlink" title="在VUE下使用axios"></a>在VUE下使用axios</h2><p><strong>step1:</strong>在项目中安装axios</p><pre class=" language-javascript"><code class="language-javascript">npm install axios</code></pre><p><strong>setp2:</strong>在main.js中引入axios</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span></code></pre><p><strong>step3:</strong>在第二步的基础上使用axios</p><pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$http <span class="token operator">=</span> axios</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习笔记---性能优化篇</title>
      <link href="/2019/05/15/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/"/>
      <url>/2019/05/15/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="提高webpack的打包速度"><a href="#提高webpack的打包速度" class="headerlink" title="提高webpack的打包速度"></a>提高webpack的打包速度</h2><ol><li><p>尽可能在更少的文件中使用loader，比如在使用babel-loader时，通过exclude来排除掉在node_modules里面的js文件，这样可以提高打包速度。</p></li><li><p>Plugin尽可能精简并且确保可靠（尽可能少的去使用插件）</p></li><li><p>resolve参数要合理配置</p></li><li><p>使用DLLPlugin提高打包速度。核心思想时利用DLLPlugin和DLLReferencePlugin预编译资源模块，通过DLLPlugin来引进那些我们引用但是绝对不会改变的npm包来进行预编译，再通过DLLReferencePlugin将预编译的模块加载进来。</p><ol><li>新建一个文件，名字叫做<code>webpack.dll.js</code>,里面内容如下：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token punctuation">{</span>    mode<span class="token punctuation">:</span><span class="token string">'production'</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>        vendors<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'vue'</span><span class="token punctuation">,</span><span class="token string">'vue-router'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//这里写的是不会修改的那些只用解析一次的模块</span>    <span class="token punctuation">}</span>，    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span><span class="token string">"[name].dll.js"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//打包生成的文件名字，这里最终生成的文件是vendors.dll.js</span>        path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">"./dll"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//这些文件打包之后会存在dll文件夹里</span>        library<span class="token punctuation">:</span><span class="token string">'[name]'</span><span class="token comment" spellcheck="true">//将打包出来的东西暴露给全局</span>    <span class="token punctuation">}</span>，    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DLLPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span><span class="token string">'[name]'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//这里和output属性的libiary保持一致</span>            path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll/[name].manifest.json'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>在package.json的script中加上一条指令：</li></ol><pre class=" language-json"><code class="language-json"><span class="token property">"script"</span><span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token property">"build:dll"</span><span class="token operator">:</span><span class="token string">"webpack --config webpack.dll.js"</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>在命令行里运行<code>npm run build:dll</code></li><li>安装另外一个插件<code>npm install add-asset-html-webpack-plugin -D</code></li><li>修改webpack.common.js文件，在里面新增如下内容：</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> AddAssetHtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'add-asset-html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">//这个插件的作用是往htmlwebpackplugin插件生成的html上面新增一些静态文件，这里新增的是vendors.dll.js</span>    <span class="token keyword">new</span> <span class="token class-name">AddAssetHtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filepath<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'vendors.dll.js'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DLLReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        manifest<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll/vendors.manifest.json'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><ol start="5"><li>使用parallel-webpack,happypack多进程打包</li></ol><h2 id="多页面应用打包"><a href="#多页面应用打包" class="headerlink" title="多页面应用打包"></a>多页面应用打包</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 多入口</span><span class="token keyword">let</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        home<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>        other<span class="token punctuation">:</span> <span class="token string">'./src/other.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">"[name].js"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//这里的name就是entry里面的两个文件，可以是home，也可以是other</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist2'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span> <span class="token string">'./index.html'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'home.html'</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//在chunks里面加入你想在这个页面中引入的js文件。</span>            chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'home'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//表示home.html里面引入的是打包生成的home.js</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span> <span class="token string">'./index.html'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'other.html'</span><span class="token punctuation">,</span>            chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'other'</span><span class="token punctuation">,</span> <span class="token string">'home'</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// other.html 里面有 other.js &amp; home.js</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型</title>
      <link href="/2019/05/09/%E5%8E%9F%E5%9E%8B/"/>
      <url>/2019/05/09/%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型的本质：对象</p><ol><li>所有的<strong>函数</strong>都有原型属性<strong>prototype</strong></li><li>默认情况下，prototype是一个对象</li><li>prototype中默认包含一个属性：constructor，该属性指向函数对象本身。</li></ol><h2 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h2><ol><li>所有对象都有一个隐式原型属性<code>__proto__</code></li><li>隐式原型是一个对象，指向创建该对象的构造函数的原型对象。</li><li>在查找对象成员时，如果在对象身上没有找到，就会去对象的隐式原型中查找。</li></ol><p><strong>所有函数的隐式原型都指向Function的原型</strong></p><p><strong>所有对象的隐式原型都指向Object的原型</strong></p><p><strong>总结</strong>：</p><p>原型对象，实例对象，构造函数之间的关系如图所示：</p><p><img src="/2019/05/09/原型/原型图解.PNG" alt></p><p><strong>特殊情况</strong>：</p><p><strong>Function的原型指向Function的隐式原型</strong>，即<code>Function.prototype===Function.__proto__</code></p><p><strong>Object原型的隐式原型指向null.</strong>即<code>Object.prototype.__proto__ ===null</code></p><p><strong>Tips</strong></p><ol><li><code>Object.__proto__ ===Function.prototype</code>:可以理解为Object这个函数(对象)是由Function函数实例化的的，所以就指向Function函数的原型对象。</li><li><code>Function.prototype.__proto__ ===Object.prototype</code>:可以理解为<code>Function.prototype</code>是一个对象，对而任何对象的隐式原型都指向Object函数的原型对象。</li></ol><p><strong>最后，关于Function，Object，自定义构造函数，实例对象的图解</strong></p><p><img src="/2019/05/09/原型/链条的全貌.jpg" alt></p><p>注释如下：</p><pre class=" language-javascript"><code class="language-javascript">自定义对象<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span>自定义构造函数<span class="token punctuation">.</span>prototype自定义构造函数<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span>Object<span class="token punctuation">.</span>prototypeObject<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span><span class="token keyword">null</span>自定义构造函数<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span>Function<span class="token punctuation">.</span>prototypeFunction<span class="token punctuation">.</span>__proto__<span class="token operator">===</span>Function<span class="token punctuation">.</span>prototypeFunction<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span>Object<span class="token punctuation">.</span>prototypeObject<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype</code></pre><p><strong>我的理解</strong></p><p><img src="/2019/05/09/原型/关系图.PNG" alt></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li>由于原型<code>prototype</code>本身是对象，因此，它也有隐式原型，指向的规则不变；这样一来，从某个对象出发，依次寻找隐式原型的指向，将形成一个链条，该链条叫做原型链。</li><li>在查找对象成员时，若对象本身没有该成员，则会到原型链中查找。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习过程中遇到的经典算法题</title>
      <link href="/2019/05/05/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
      <url>/2019/05/05/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>说明</strong>：这个帖子旨在记录在学习JavaScript期间遇到的一些有趣的编程题。</p><h2 id="平衡括号"><a href="#平衡括号" class="headerlink" title="平衡括号"></a>平衡括号</h2><p><strong>题目描述</strong>：在编写代码并且编译时，难免会因为少写了一个’)’和被编译器报错。也就是说，编译器会去匹配括号是否匹配。当你输入了一个’(‘，很自然编译器回去检查你是否有另一个’)’符号与之匹配。如果所有的括号都能够成对出现，那么编译器是能够通过的。否则编译器会报错。</p><p><strong>算法描述</strong>：创建一个空栈，读取字符给定的字符串序列直到结尾，如果字符是开放符号’(‘,’[‘,’{‘则入栈，如果是’)’,’]’,’}’,首先判断当前栈是否为空，如果为空，则返回false，如果不为空，则判断栈顶元素是否是当前字符匹配的括号，如果不匹配，则返回false，如果匹配，则讲当前栈顶元素弹出。依次循环遍历完字符串，如果此时栈为空，则该字符串是一个括号平衡的字符串。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//定义一个栈</span><span class="token keyword">function</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//压栈</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>push<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">{</span>        items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//出栈</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pop<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回栈顶元素</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>peek <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>items<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断栈是否为空</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>isEmpty <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断函数</span><span class="token keyword">function</span> <span class="token function">balanceSigned</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">'('</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">'['</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">'{'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">')'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">']'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">case</span> <span class="token string">'}'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>                <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    flag <span class="token operator">=</span> stack<span class="token punctuation">.</span>isEmpty<span class="token punctuation">;</span>    <span class="token keyword">return</span> flag<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="硬币找零"><a href="#硬币找零" class="headerlink" title="硬币找零"></a>硬币找零</h2><p><strong>问题描述</strong>：给出要找零的钱数，以及可用的硬币面额，找到所需最少的硬币个数。</p><p><strong>算法描述</strong>：采用贪心算法，从面额最大的硬币开始，拿尽可能多的这种硬币找零，当无法再拿更多的这种面值的硬币时，开始拿第二大价值的硬币。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">change</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//coins是面值数组，排序是为了防止给定的面值集合数组是无序的。</span>    <span class="token comment" spellcheck="true">//amount是需要找零的面值</span>    coins<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>b<span class="token operator">-</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最终结果放在res里面</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//count是当前选择完后累计的钱数。</span>    <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">+</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>amount<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">+</span><span class="token operator">=</span>coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h2><p><strong>问题描述</strong>：JavaScript和任何一门语言一样，对其数值的范围有限制。如果我们想要对一个超大的整数进行加法运算，但是又想输出一般形式，那么使用 <code>+</code> 是无法达到的一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。在此时就需要自己实现一套加法算法。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sumBigNumber</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span>    temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">||</span> b<span class="token punctuation">.</span>length <span class="token operator">||</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    temp <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token operator">~</span>a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token operator">~</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用 ~~a 而不是Number(a)来进行格式转换。</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span>temp <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> res<span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^0+/</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>算法解释</strong>：</p><ol><li>首先我们用字符串来保存大数，就保证了其在数学表示上不会发生变化。</li><li>初始化<code>res, temp</code>变量来保存中间计算的结果，在将两个字符串<code>split</code>为数组，以便我们进行每一位的运算。</li><li>循环的第一次就是进行 “个位” 的运算，将二者最末尾的两个数相加，由于每一位数字是0 - 9，所以需要进行进位，在进过取余数操作后，将结果保留在个位。</li><li>判断 <code>temp</code> 是否大于 10，若是则将 <code>temp</code> 赋值为 <code>true</code>。</li><li>在两个大数中的一个还有数字没有参与运算，或者前一次运算发生进位后，进行下一次循环。</li><li>接着除了对新的两个数字相加还要加上 <code>temp</code>，若上次发生了进位，则此时 <code>temp</code> 为 <code>true</code>，JavaScript因为存在隐式转换，所以 <code>true</code> 转换为 1，我们借用 JavaScript的类型转换，完成了逻辑上的逢10进1操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制</title>
      <link href="/2019/05/04/javascript%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/04/javascript%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="原理：找出不再继续使用的变量，然后释放掉其占用的内存。"><a href="#原理：找出不再继续使用的变量，然后释放掉其占用的内存。" class="headerlink" title="原理：找出不再继续使用的变量，然后释放掉其占用的内存。"></a>原理：找出不再继续使用的变量，然后释放掉其占用的内存。</h2><h2 id="策略1：标记清除"><a href="#策略1：标记清除" class="headerlink" title="策略1：标记清除"></a>策略1：标记清除</h2><p>当变量进入环境（可以理解为一个函数开始执行了）时，就将这个变量标记为“进入环境”，从逻辑上讲，不能释放掉进入环境的变量，而当变量离开环境的的时候，则将其标记为离开环境。</p><ol><li>垃圾收集器在运行的时候会给存储在内存中的<strong>所有变量都加上标记</strong>。</li><li>去掉<strong>环境中的变量以及被环境中的变量引用的变量</strong>的标记。</li><li>此后<strong>再被加上标记的变量</strong>将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了。</li></ol><h2 id="策略2：引用计数"><a href="#策略2：引用计数" class="headerlink" title="策略2：引用计数"></a>策略2：引用计数</h2><p>跟踪记录每一个值的引用次数，当声明了一个变量并将一个引用类型值赋给该变量的时候，这个引用类型的引用次数就是1，如果同一个值又被赋值给另一个变量，这个值的引用次数加1.如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1，当这个值引用次数为0的时候，就可以将这个引用值所占的内存空间回收回来。</p><p><img src="/2019/05/04/javascript垃圾收集机制/引用计数.png" alt></p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>如果存在循环引用的情况，那么这个引用值占的空间就永远不会被回收。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串常用方法</title>
      <link href="/2019/04/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="length"><a href="#length" class="headerlink" title=".length"></a>.length</h3><p>返回字符换长度</p><h3 id="charAt-索引"><a href="#charAt-索引" class="headerlink" title=".charAt(索引)"></a>.charAt(索引)</h3><p>返回指定索引位置的字符，如果索引超过了字符串长度会返回空串</p><h3 id="charCodeAt-索引"><a href="#charCodeAt-索引" class="headerlink" title=".charCodeAt(索引)"></a>.charCodeAt(索引)</h3><p>返回给定索引位置的字符的字符编码</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">chaAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回的是字符‘e’</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回的是一个空串</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回的是字符‘e’的字符编码101</span></code></pre><h3 id="concat-字符串1，字符串2…"><a href="#concat-字符串1，字符串2…" class="headerlink" title=".concat(字符串1，字符串2…)"></a>.concat(字符串1，字符串2…)</h3><p>返回的是拼接之后的新的字符串</p><h3 id="indexOf-要找的字符，开始的位置（可选项）"><a href="#indexOf-要找的字符，开始的位置（可选项）" class="headerlink" title=".indexOf(要找的字符，开始的位置（可选项）)"></a>.indexOf(要找的字符，开始的位置（可选项）)</h3><p>返回的是从开始的位置之后第一个出现目标字符串的位置，没有找到就返回-1</p><h3 id="lastIndexOf-要找的字符，开始的位置（可选项）"><a href="#lastIndexOf-要找的字符，开始的位置（可选项）" class="headerlink" title=".lastIndexOf(要找的字符，开始的位置（可选项）)"></a>.lastIndexOf(要找的字符，开始的位置（可选项）)</h3><p>返回的是目标字符最后出现的位置，没有就返回-1</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">'world'</span><span class="token punctuation">,</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出字符串‘hello，world！’</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出3</span></code></pre><h3 id="replace-原来的字符串，新的字符串"><a href="#replace-原来的字符串，新的字符串" class="headerlink" title=".replace(原来的字符串，新的字符串)"></a>.replace(原来的字符串，新的字符串)</h3><p>将原来的字符串用新的字符串代替，<strong>如果原来字符串出现了多次，只会替换第一个出现的，并不会全局替换</strong></p><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>去掉字符串首位两端的空格</p><h3 id="split-分隔符，保留下来的个数（可选）"><a href="#split-分隔符，保留下来的个数（可选）" class="headerlink" title=".split(分隔符，保留下来的个数（可选）)"></a>.split(分隔符，保留下来的个数（可选）)</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">' hello '</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出字符串‘hexlo’</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出首尾没有空格的字符串‘hello’</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">'h,e,l,l,o'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出一个数组['h','e','l','l',''o];</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出数组['h','e']</span></code></pre><h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title=".toLowerCase"></a>.toLowerCase</h3><p>将字符串全部换为小写</p><h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h3><p>将字符串全部换为大写</p><h3 id="localeCompare-要进行比较的字符串"><a href="#localeCompare-要进行比较的字符串" class="headerlink" title=".localeCompare(要进行比较的字符串)"></a>.localeCompare(要进行比较的字符串)</h3><ol><li>如果字符串在字母表中应该排在参数前，则返回一个负数</li><li>如果字符串等于参数，返回0；</li><li>如果字符串应该排在参数之后，返回一个正数</li></ol><h3 id="slice-substring-substr方法"><a href="#slice-substring-substr方法" class="headerlink" title="slice,substring substr方法"></a>slice,substring substr方法</h3><p>这三个方法都会返回被操作字符串的一个子字符串，而且也都可以接收一个或者两个参数。其中，第一个参数指定子字符串的开始位置，第二个参数是可选的，用于指定子字符串结束的位置。具体而言，<strong>slice和subString的第二个参数指定的是子字符串最后一个字符后面的位置，而substr的第二个参数指定的是返回字符串的长度</strong>。如果没有给这些方法传入第二个参数，则将字符串的末尾作为结束的位置。</p><p>但是，如果在给这三个方法传入的参数是负值的时候，则情况不尽相同，具体而言：</p><ol><li>slice：将传入的负值与字符串长度相加，转为正值</li><li>substr：将负的第一个参数加上字符串的长度，而将负的第二个参数转为0</li><li>substring：将所有负的参数转为0，但是该方法以参数中较小的数作为开始的位置，较大的那个数作为结束的位置。</li></ol><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello, world!'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出‘ello, world!’</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出‘ello, world!’</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出‘ello, world!’</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出从第二个字符开始，到第六个字符结束的中间的字符串</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出从第二个字符开始，到第六个字符结束的中间的字符串</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出从第二个字符开始往后的长度为6的字符串</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于str.slice(13-5)=>str.slice(8)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于str.slice(13-5)=>str.slice(8)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于str.substring(5, 0)=>str.substring(0,5)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES5基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD/CMD和CommonJS的区别</title>
      <link href="/2019/04/26/AMD/"/>
      <url>/2019/04/26/AMD/</url>
      
        <content type="html"><![CDATA[<ol><li>commonjs是用在服务器端的，是同步的，如node.js</li><li>amd,cmd是用在浏览器端的，是异步的。其中amd先提出来，cmd是根据commonjs和amd的基础上提出来的。</li></ol><h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>Commonjs是服务器端的模块规范，Node.js采用了这个规范</p><p>根据Commonjs规范，一个单独的文件就是一个模块，加载模块使用require方法，该方法读取文件并执行，最后，返回文件的内部expots对象。</p><p>CommonJS加载模块是同步的，只有加载完成之后才可以执行后面的操作。像Node.js主要用于服务器的编写，加载的模块文件一般都已经存在本地硬盘上了，所以加载起来比较快。不用考虑异步加载的方式。所以，CommonJS规范比较适用。但是如果是在浏览器端，要从服务器加载模块，就必须是异步模式，所以才有了AMD,CMD解决方案。</p><h2 id="AMD-CMD"><a href="#AMD-CMD" class="headerlink" title="AMD/CMD"></a>AMD/CMD</h2><p>AMD是“Asynchronous Module Definition”的缩写，意思就是“异步模块定义”，它采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖的模块的语句，都定义在一个回调函数中，等到加载完之后，这个回调函数才会运行。</p><p>AMD也采用了require语句加载模块，但是不同于CommonJS</p><p>主要由两个JavaScript库实现了AMD规范。require.js和curl.js</p><p><strong>相同点</strong>：都是异步加载</p><p>AMD推崇前置依赖，在定义模块的时候就要声明其依赖的模块。AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p><p>CMD推崇后置依赖，只有在用到某个模块的时候才去require。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p><p>对于依赖的模块，AMD是提前执行的，CMD是延迟执行的。</p><p>CMD在AMD基础上改进，可按需加载，预先下载代码，但并没有立即执行，即“就近书写，延迟执行”</p><pre class=" language-javascript"><code class="language-javascript">AMD<span class="token comment" spellcheck="true">//a.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.js'</span>执行<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        hello<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//b.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.js执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        hello<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello, b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//main.js</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main.js执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        b<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript">CMD<span class="token comment" spellcheck="true">//a.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.js执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        hello<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.js执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        hello<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is b.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//main.js</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main.js执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtual DOM及diff算法</title>
      <link href="/2019/04/22/vdom/"/>
      <url>/2019/04/22/vdom/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是virtual-dom？"><a href="#什么是virtual-dom？" class="headerlink" title="什么是virtual dom？"></a>什么是virtual dom？</h2><p>从本质上而言，Vdom只是一个用于描述DOM节点的原生JS对象，并且最少包括tag，props，和children三个属性，下面是一个经典的Vdom例子：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    tag<span class="token operator">:</span> <span class="token string">"div"</span><span class="token punctuation">,</span>    props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    children<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"Hello World"</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>            tag<span class="token operator">:</span> <span class="token string">"ul"</span><span class="token punctuation">,</span>            props<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>                tag<span class="token operator">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span>                props<span class="token operator">:</span> <span class="token punctuation">{</span>                    id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>                    class<span class="token operator">:</span> <span class="token string">"li-1"</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"第"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>Vdom和实际的dom对象有着意一一对应的关系，上述的Vdom就是由以下HTML生成的</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    Hello World    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>li-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            第1        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><h2 id="当数据发生变化时，Vue如何更新节点？"><a href="#当数据发生变化时，Vue如何更新节点？" class="headerlink" title="当数据发生变化时，Vue如何更新节点？"></a>当数据发生变化时，Vue如何更新节点？</h2><p>渲染真实的DOM的开销是很庞大的，如果直接渲染到真实的DOM上会引起整个DOM树的重排重绘，通过diff算法来实现只更新一小块DOM而不更新整个DOM。首先，根据真实的DOM生成一颗Virtual DOM。当vitrual DOM的某个节点的数据发生变化的时候会生成一个新的VNode。(vue.js中采用createElement方法来创建Vnode)。然后Vnode和old vnode做对比，发现有不一样的地方就修改在真实的DOM上，然后使old Vnode的值为Vnode。</p><p>diff算法的过程就是调用名为patch的函数，比较新旧节点，一边比较，一边给真实的节点打补丁。</p><p><strong>注意</strong></p><ol><li>Vnode和old vnode都是对象</li><li>在采用diff算法进行新旧节点比较的时候，比较只会在同一层级上比较，不会跨层级去比较。</li></ol><p>patch函数有两个参数，Vnode和old Vnode也就是新旧俩个虚拟节点，具体而言有两个步骤：</p><ol><li>判断两个节点是否值得比较，值得比较就调用patch vnode算法（此处调用的是sameVnode函数）</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> sameVnode <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>            <span class="token punctuation">(</span>                a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>                a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span>                <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>            <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>                <span class="token function">isTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                a<span class="token punctuation">.</span>asyncFactory <span class="token operator">===</span> b<span class="token punctuation">.</span>asyncFactory <span class="token operator">&amp;&amp;</span>                <span class="token function">isUndef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>error<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span>sameVnode的逻辑比较简单，如果两个vnode的key不相等，则是不等的，否则继续判断tag值，data等类型是否相等</code></pre><ol><li>不值得比较就直接用VNode替换掉old Vnode</li></ol><p>patchVnode做的事情：</p><ol><li>找到old vnode对应的真实Vdom，称为el</li><li>如果oldVnode===vnode，他们的引用一致，可以认为没有变化，则直接return</li><li>如果两者都有文本节点，且文本节点不相等，则将el的文本节点设置为vnode的文本节点</li><li>如果新节点有子节点而oldnode没有子节点，则将vnode的子节点真实化后添加到el上</li><li>如果新节点没有子节点而oldnode有子节点，则将el的子节点删除掉</li><li>如果两者都有子节点，则调用updatechildren函数比较子节点。</li></ol><p>updateChildren函数的作用</p><ol><li>处理头部的同类型节点：即oldStart和newStart指向同类节点的情况。—-&gt;将oldStart和newStart向后移动一位</li><li>处理尾部的同类型节点：即oldEnd和newEnd指向同类节点的情况。—-&gt;将oldEnd和newEnd向前移动一位。</li><li>处理头尾/尾头的同类型节点：即oldStart和newEnd以及oldEnd和newStart指向同类节点的情况。</li></ol><p><img src="/2019/04/22/vdom/0.png" alt></p><p>节点2后移到oldEnd指向的节点（节点9）的后面，移动后标记该节点，并将oldstart后移一位，newEnd前移一位，变为：</p><p><img src="/2019/04/22/vdom/1.png" alt></p><p>同样地，节点9也是类似的处理，处理完之后成了下面这样</p><p><img src="/2019/04/22/vdom/3.png" alt></p><p>newStart来到了节点11的位置，在oldVdom中找不到节点11，说明它是新增的。那么就创建一个新的节点，插入DOM树，插到什么位置？插到oldStart指向的节点（即节点3）前面，然后将newStart后移1位标记为已处理（注意oldVdom中没有节点11，所以标记过程中它的指针不需要移动），处理之后如下图</p><p><img src="/2019/04/22/vdom/4.png" alt></p><p>处理更新的节点：</p><p>经过第（4）步之后，newStart来到了节点7的位置，在oldVdom中能找到它而且不在指针位置（<strong>查找oldVdom中oldStart到oldEnd区间内的节点</strong>），说明它的位置移动了，那么需要在DOM树中移动它，移到哪里？移到oldStart指向的节点（即节点3）前面。<strong>与此同时将节点标记为已处理</strong>    </p><p><img src="/2019/04/22/vdom/6.png" alt></p><p>处理之后就成了下面这样：</p><p><img src="/2019/04/22/vdom/7.png" alt></p><p>处理需要删除的节点：</p><p>经过前面处理之后，newStart跨过了newEnd，它们相遇啦！而这个时候，oldStart和oldEnd还没有相遇，说明这2个指针之间的节点（包括它们指向的节点，即上图中的节点7、节点8）是此次更新中被删掉的节点。</p><p>OK，那我们在DOM树中将它们删除，<strong>再回到前面我们对节点7做了标记，为什么标记是必需的？标记的目的是告诉Vue它已经处理过了，是需要出现在新DOM中的节点，不要删除它，所以在这里只需删除节点8。</strong></p><p><strong>在应用中也可能会遇到oldVdom的起止点相遇了，但是newVdom的起止点没有相遇的情况，这个时候需要对newVdom中的未处理节点进行处理，这类节点属于更新中被加入的节点，需要将他们插入到DOM树中。</strong></p><p><img src="/2019/04/22/vdom/10.png" alt></p><h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>key的作用是给每个节点做一个唯一标识，从而在diff算法执行时更快的找到对应的节点，提高diff速度。</p><p>在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的key去对比旧节点数组中的key，从而找到相应的旧节点，如果没找到就认为是新增加一个节点，而如果没有key，就会采用遍历查找的方式去找对应的旧节点。</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> diff算法 </tag>
            
            <tag> VDom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6异步操作</title>
      <link href="/2019/04/11/ES6%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/11/ES6%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async函数返回的是一个promise对象，如果在函数中return一个直接量，saync会把这个直接量通过Promise.resolve()封装成一个Promise对象。，如果async函数没有返回值，就会封装成async(undefined)</p><p><strong>个人理解</strong>：async函数在调用完毕之后，不管函数本身有没有设置返回值，都会自动返回一个Promise对象。如果async函数有设置返回值，则返回的Promise对象是Promise.resolve(返回值)，如果async本身没有设置返回值，则返回的Promise对象是Promise.resolve(undefined).</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> async/await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript运行机制</title>
      <link href="/2019/04/11/EventLoop/"/>
      <url>/2019/04/11/EventLoop/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么JavaScript是单线程"><a href="#为什么JavaScript是单线程" class="headerlink" title="为什么JavaScript是单线程"></a>为什么JavaScript是单线程</h2><p>JavaScript的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript的主要用途是为了与用户互动以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如：假定JavaScript同时又两个线程，一个线程在某个DOM节点上添加内容，一个线程要删除这个节点，这时，浏览器就不知道该以哪个线程为准。</p><h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><p>同步任务：在主线程上排队执行额任务，只有前一个任务执行完毕之后才能执行下一个任务。</p><p>异步任务：不进入主线程，而是进入任务队列的任务。</p><p><strong>注</strong>：除了放置异步任务的事件，任务队列还可以放置定时器任务。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>任务队列是一个事件的队列，主线程读取任务队列，就是读取里面的事件。</p><p>主线程从“任务队列”中读取事件，这种过程是循环不断的，所以整个过程的运行机制又称为EventLoop</p><p>不同的任务源会被分配到不同的Task队列中去，任务源又可以分为微任务(miscrotask)和宏任务(mascrotask)</p><p><img src="/2019/04/11/EventLoop/宏任务和微任务.PNG" alt></p><p>EventLoop循环过程如下：</p><ol><li>执行完同步代码，当所有同步代码均被执行完毕之后，执行栈清空，查询是否有异步代码</li><li>在macrotask队列中选择最早的那一个，如果没有可选的任务，就跳到下面的microtask队列中</li><li>将上面选中的macrotask设置为正在运行的task</li><li>运行被选中的task</li><li>运行完毕之后，将eventloop中的current running task设置为null</li><li>从task队列中移除前面运行的macrotask</li><li>执行所有在microtask队列里的任务。</li><li>更新渲染</li><li>返回到开始</li></ol><h3 id="另一理解"><a href="#另一理解" class="headerlink" title="另一理解"></a>另一理解</h3><ol><li>一段代码执行时先执行宏任务中的同步代码</li><li>如果遇到像setTimeOut这种宏任务就会把代码放置在宏任务队列中去</li><li>如果遇到promise.then这类任务会放置在微任务队列中。</li><li>在本轮宏任务执行完之后会依此执行本轮微任务队列中的所有代码，然后开始下一轮的宏任务代码。</li></ol><p><strong>注</strong>：await后面无论接的是同步代码还是异步代码都必须等他们执行完毕之后才能执行await结果后面的代码。</p><p><strong>注释</strong>：在遇见定时器后，会将定时器内的函数进行注册，也就是放在Event Table。然后在定时器设定的事件后将Event Table内注册的函数放入Event queue。如果主线程中的call stack为空就将Event queue按顺序放入call stack中进行执行，如果call stack并不为空，Event queue内的事件并不会进入call stack，也就不会执行。</p><p>在call stack中的内容执行完毕后清空，会在Event queue检查一下哪些任务时宏任务，哪些是微任务，然后执行所有的微任务，然后执行下一个宏任务，之后再次执行所有的微任务。也就是说在主线程任务执行完毕后会把任务队列里的微任务全部执行，然后再执行下一个宏任务，这个宏任务执行完再次检查队列内部的微任务，有就全部执行，没有就再执行一个宏任务。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
